<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>wdnotes</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22512%22%20height%3D%22512%22%20viewBox%3D%220%200%20512%20512%22%3E%3Crect%20width%3D%22100%25%22%20height%3D%22100%25%22%20rx%3D%228%22%20ry%3D%228%22%20fill%3D%22%230a8cd8%22%2F%3E%3Cpath%20d%3D%22M256%2084%20C210%2084%20174%20126%20174%20176%20C174%20222%20206%20256%20206%20300%20L206%20336%20C206%20352%20220%20366%20256%20366%20C292%20366%20306%20352%20306%20336%20L306%20300%20C306%20256%20338%20222%20338%20176%20C338%20126%20302%2084%20256%2084%22%20fill%3D%22none%22%20stroke%3D%22%23ffffff%22%20stroke-width%3D%2224%22%20stroke-linecap%3D%22round%22%20stroke-linejoin%3D%22round%22%2F%3E%3Crect%20x%3D%22196%22%20y%3D%22366%22%20width%3D%22120%22%20height%3D%2228%22%20rx%3D%228%22%20ry%3D%228%22%20fill%3D%22%23ffffff%22%2F%3E%3Cpath%20d%3D%22M256%20414%20m-34%200%20a34%2020%200%201%200%2068%200%20a34%2020%200%201%200%20-68%200%22%20fill%3D%22%23ffffff%22%2F%3E%3C%2Fsvg%3E" type="image/svg+xml">
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons&display=swap" rel="stylesheet"> 
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" rel="stylesheet">

  <style>
    :root {
        --editor-font: "iA-Mono", "Menlo", 'Courier New', Courier, monospace;
        --primary-color: #6366f1; --primary-dark: #4f46e5; --secondary-color: #8b5cf6; --accent-color: #06b6d4; --success-color: #10b981; --warning-color: #f59e0b; --danger-color: #ef4444; --bg-primary: #0f172a; --bg-secondary: #1e293b; --bg-tertiary: #334155; --text-primary: #f1f5f9; --text-secondary: #94a3b8; --text-muted: #64748b; --border-color: #475569; --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.1); --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.2); --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.25); --border-radius: 0.75rem; --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        --surface-color: #1e293b;
        --input-background: #334155;
        --shadow-color: rgba(0, 0, 0, 0.4);
    }
    body.light-theme {
        --bg-primary: #f1f3f4; --bg-secondary: #ffffff; --bg-tertiary: #f8f9fa; --text-primary: #212529; --text-secondary: #495057; --text-muted: #6c757d; --border-color: #dee2e6;
        --surface-color: #ffffff;
        --input-background: #f8f9fa;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --primary-color: #0a8cd8; --primary-dark: #006ead;
    }
    
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: var(--bg-primary); color: var(--text-primary); margin: 0;
      padding-top: 75px; font-size: 16px; display: flex; flex-direction: column; min-height: 100vh;
      transition: background-color 0.3s, color 0.3s;
    }
    body.modal-active, body.multi-select-active {
        overflow: hidden;
    }
    .main-container { padding: 0 15px 15px 15px; flex-grow: 1; }

    #top-action-bar {
      background-color: var(--bg-secondary); border-radius: 8px; padding: 8px 12px; 
      margin: 15px 15px 0 15px;
      display: flex; align-items: center;
      position: fixed; top: 0; left: 0; right: 0; z-index: 99; height: 56px;
      transition: opacity 0.2s, transform 0.2s, background-color 0.3s, box-shadow 0.3s;
      border: 1px solid var(--border-color);
      box-shadow: var(--shadow-md);
    }
    body.multi-select-active #top-action-bar {
        opacity: 0; transform: translateY(-20px); pointer-events: none;
    }
    #multi-select-action-bar {
        background-color: var(--bg-tertiary);
        border-radius: 8px; padding: 8px 12px; 
        margin: 15px 15px 0 15px;
        display: flex; align-items: center; justify-content: space-between;
        position: fixed; top: 0; left: 0; right: 0; z-index: 100; height: 56px;
        box-shadow: var(--shadow-lg); border: 1px solid var(--border-color);
        opacity: 0; transform: translateY(-20px);
        transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
        pointer-events: none;
    }
    #multi-select-action-bar.visible {
        opacity: 1; transform: translateY(0); pointer-events: auto;
    }
    #multi-select-action-bar .selection-info { display: flex; align-items: center; }
    #multi-select-action-bar #selection-count { font-weight: 500; font-size: 1.1rem; color: var(--text-primary); }
    #multi-select-action-bar .actions button {
      background: transparent; border: none; color: var(--text-secondary); cursor: pointer;
      padding: 8px; border-radius: 50%; display: inline-flex;
      align-items: center; justify-content: center; margin: 0 4px;
    }
    #multi-select-action-bar .actions button:hover { background-color: rgba(255,255,255,0.1); }
    body.light-theme #multi-select-action-bar .actions button:hover { background-color: rgba(0,0,0,0.08); }


    #hamburger-menu-btn {
      background-color: transparent; border: none; color: var(--text-secondary); cursor: pointer;
      padding: 8px; border-radius: 50%; display: inline-flex;
      align-items: center; justify-content: center; margin-right: 12px; 
    }
    #hamburger-menu-btn:hover { background-color: var(--bg-tertiary); }
    #hamburger-menu-btn .material-icons { font-size: 22px; }
    #universal-note-input {
      flex-grow: 1; border: none; outline: none; font-size: 1.2rem;
      padding: 8px 0; background-color: transparent; color: var(--text-primary);
    }
    #universal-note-input::placeholder { color: var(--text-muted); opacity: 1; font-size: 1.2rem;}
    .top-bar-actions { display: flex; align-items: center; margin-left: 12px; }
    .top-bar-actions button {
      background-color: transparent; border: none; color: var(--text-secondary); cursor: pointer;
      padding: 8px; border-radius: 50%; display: inline-flex; 
      align-items: center; justify-content: center;
    }
    .top-bar-actions button:hover { background-color: var(--bg-tertiary); }
    .top-bar-actions button .material-icons { font-size: 22px; }
    .top-bar-actions button + button { margin-left: 4px; }
    
    .btn, .btn-floating { box-shadow: none; font-weight: 500; text-transform: none;}

    #notes-grid-container { 
      column-gap: 15px;
      column-count: 1;
    }
    @media (min-width: 600px) { #notes-grid-container { column-count: 2; } }
    @media (min-width: 900px) { #notes-grid-container { column-count: 3; } }
    @media (min-width: 1200px) { #notes-grid-container { column-count: 4; } }
    @media (min-width: 1500px) { #notes-grid-container { column-count: 5; } }
    
    .grid-section-title {
        column-span: all; margin: 20px 0 10px 5px;
        color: var(--text-muted); font-size: 0.875rem; font-weight: 500;
        text-transform: uppercase; letter-spacing: .075em;
    }
    .note-card {
      background-color: var(--bg-secondary); border: 1px solid var(--border-color);
      border-radius: var(--border-radius); box-shadow: var(--shadow-md);
      cursor: pointer; transition: var(--transition); position: relative;
      display: inline-flex; flex-direction: column;
      margin-bottom: 15px; break-inside: avoid; width: 100%;
    }
    
    .note-card:hover { box-shadow: var(--shadow-lg); transform: translateY(-2px); }
    .note-card-header { padding: 12px 15px 8px 15px; border-bottom: 1px solid var(--border-color); }
    .note-card-title-display { 
        font-weight: 600; color: var(--text-primary); font-size: 1.2rem;
        word-break: break-word; overflow-wrap: break-word;
        -webkit-backface-visibility: hidden; backface-visibility: hidden;
    }
    
    .note-card-content {
      padding: 12px 15px; font-size: 1.1rem;
      line-height: 1.5; word-wrap: break-word;
      flex-grow: 1; overflow: hidden; color: var(--text-secondary);
    }
    .note-card-content > :first-child { margin-top: 0; }
    .note-card-content > :last-child { margin-bottom: 0; }
    
    .note-card-content h1, #note-editor-contenteditable h1,
    .note-card-content h2, #note-editor-contenteditable h2,
    .note-card-content h3, #note-editor-contenteditable h3,
    .note-card-content h4, #note-editor-contenteditable h4,
    .note-card-content h5, #note-editor-contenteditable h5,
    .note-card-content h6, #note-editor-contenteditable h6 {
        color: var(--text-primary);
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 4px;
        margin-bottom: 0.75em;
        margin-top: 1em;
    }

    .note-card-content h1, #note-editor-contenteditable h1 { font-size: 1.5em; }
    .note-card-content h2, #note-editor-contenteditable h2 { font-size: 1.2em; }
    .note-card-content h3, #note-editor-contenteditable h3 { font-size: 1.1em; }
    .note-card-content h4, #note-editor-contenteditable h4,
    .note-card-content h5, #note-editor-contenteditable h5,
    .note-card-content h6, #note-editor-contenteditable h6 { font-size: 1em; }
    
    .note-card-content p { margin: 0 0 0.5em 0; }
    .note-card-content ul, .note-card-content ol { padding-left: 20px; margin: 0 0 0.5em 0; }
    .note-card-content img, .note-card-content video, .note-card-content iframe {
      max-width: 100%; height: auto; border-radius: 4px;
    }
    
    .note-card-content pre, #note-editor-contenteditable pre {
        background-color: var(--bg-primary); border: 1px solid var(--border-color);
        border-radius: 4px; padding: 12px; font-family: var(--editor-font);
        white-space: pre-wrap; word-wrap: break-word; overflow-x: auto; font-size: 0.9em;
        position: relative;
    }
    .note-card-content code, #note-editor-contenteditable code { font-family: var(--editor-font); }

    .copy-code-btn {
        position: absolute; top: 5px; right: 5px;
        background-color: var(--bg-tertiary); color: var(--text-secondary);
        border: 1px solid var(--border-color); border-radius: 4px;
        cursor: pointer; opacity: 0; transition: opacity 0.2s;
        padding: 2px 5px;
    }
    pre:hover .copy-code-btn { opacity: 1; }
    .copy-code-btn:hover { background-color: var(--primary-color); color: white; }

    .note-card-content a { color: var(--accent-color); }

    .note-card-pills {
        padding: 4px 15px 8px; flex-shrink: 0; display: flex; flex-wrap: wrap; gap: 6px;
    }
    .tag-pill {
        display: inline-flex; align-items: center;
        background-color: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border-color);
        padding: 3px 12px; border-radius: 16px; font-size: 0.8em; font-weight: 500;
    }
    
    .note-actions {
      padding: 4px 8px; display: flex; justify-content: flex-end; align-items: center;
      opacity: 0; transition: opacity 0.2s ease-in-out;
      background: linear-gradient(to top, var(--bg-secondary) 30%, transparent);
      position: relative; margin-top: auto; 
    }
    .note-card:hover .note-actions { opacity: 1; }

    .note-actions button {
      background-color: transparent; border: none; color: var(--text-muted); padding: 6px; 
      border-radius: 50%; cursor: pointer; line-height: 1;
      display: inline-flex; align-items: center; justify-content: center;
    }
     .note-actions button + button { margin-left: 4px; }
    .note-actions button:hover { background-color: var(--bg-tertiary); }
    .note-actions button .material-icons { font-size: 18px; display: block; }
    .note-actions button.pinned .material-icons { color: var(--text-primary); } 
    .note-actions button.delete-btn:hover { color: var(--danger-color); }
    
    .color-palette-panel {
        position: absolute; background-color: var(--bg-secondary); border: 1px solid var(--border-color);
        box-shadow: var(--shadow-lg); border-radius: 4px;
        padding: 10px; z-index: 1001; display: flex; flex-wrap: wrap; gap: 8px;
        width: auto; max-width: 200px; bottom: 45px; left: 5px;
    }
    .color-swatch {
        width: 28px; height: 28px; border-radius: 50%;
        cursor: pointer; border: 1px solid rgba(255,255,255,0.1);
        display: flex; align-items: center; justify-content: center;
        transition: var(--transition);
    }
    .color-swatch:hover { transform: scale(1.1); }
    .color-swatch.active .material-icons { color: #000; }
    .color-swatch.active.dark-swatch .material-icons { color: #fff; }


    #loading-indicator { text-align: center; padding: 20px; font-style: italic; color: var(--text-muted); }
    #notes-count { text-align: center; color: var(--text-muted); margin-bottom: 15px; font-size:0.9em; }
    #trash-info-message { text-align: center; color: var(--text-muted); margin-bottom: 15px; }

    .hidden { display: none !important; }

    #modal-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.7); backdrop-filter: blur(4px); z-index: 1000;
    }

    #modal-editor-container {
        position: fixed; top: 50%; left: 50%;
        transform: translate(-50%, -50%); width: 80%; max-width: 700px;
        background-color: var(--bg-secondary); border-radius: var(--border-radius);
        box-shadow: var(--shadow-lg); border: 1px solid var(--border-color);
        z-index: 1001; display: flex; flex-direction: column;
        max-height: 85vh; transition: all 0.3s ease;
    }
    #modal-editor-container.fullscreen-mode {
        width: 100vw; height: 100vh; max-width: 100%; max-height: 100%;
        top: 0; left: 0; transform: none; border-radius: 0;
    }
    #modal-editor-container.fullscreen-mode #modal-note-title-input { font-size: 1.6rem; }
    #modal-editor-container.fullscreen-mode #note-editor-contenteditable { font-size: 1.25rem; line-height: 1.7; padding: 20px 40px; }

    #note-editor-wrapper {
        display: flex;
        flex-grow: 1;
        overflow: hidden;
    }

    #modal-editor-container.markdown-active {
        width: 95%;
        max-width: 1200px;
    }
    #modal-editor-container.markdown-active #note-editor-contenteditable {
        width: 50%;
        border-right: 1px solid var(--border-color);
        font-family: var(--editor-font);
        white-space: pre-wrap;
    }
    #note-editor-preview {
        width: 50%;
        overflow-y: auto;
        padding: 12px 20px;
        font-size: 1.2rem;
        line-height: 1.5;
        color: var(--text-secondary);
    }
    #note-editor-preview h1, #note-editor-preview h2, #note-editor-preview h3, #note-editor-preview h4, #note-editor-preview h5, #note-editor-preview h6 {
        color: var(--text-primary);
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 4px;
        margin-bottom: 0.75em;
        margin-top: 1em;
    }
     #note-editor-preview h1 { font-size: 1.5em; }
     #note-editor-preview h2 { font-size: 1.2em; }
     #note-editor-preview h3 { font-size: 1.1em; }

    #note-editor-contenteditable, #note-editor-preview {
        transition: width 0.3s ease-in-out;
    }
    .md-editor-only #note-editor-contenteditable { width: 100% !important; }
    .md-editor-only #note-editor-preview { width: 0 !important; padding: 12px 0; display: none; }
    .md-preview-only #note-editor-contenteditable { width: 0 !important; padding: 12px 0; border-right: none; display: none; }
    .md-preview-only #note-editor-preview { width: 100% !important; display: block !important; }


    #modal-editor-header {
        display: flex; align-items: center; border-bottom: 1px solid var(--border-color);
        flex-shrink: 0; padding: 0 12px;
    }

    #modal-note-title-input {
        border: none; outline: none; font-size: 1.4rem; font-weight: 500;
        padding: 16px 12px 16px 4px; background: transparent; flex-grow: 1; color: var(--text-primary);
    }
    
    #note-editor-contenteditable {
        flex-grow: 1; overflow-y: auto; padding: 12px 20px;
        outline: none; -ms-overflow-style: none; scrollbar-width: none;
        line-height: 1.5; font-size: 1.2rem; color: var(--text-secondary);
    }
    #note-editor-contenteditable::-webkit-scrollbar { display: none; }
    #note-editor-contenteditable img { max-width: 100%; height: auto; cursor: pointer; }
    
    .modal-editor-footer {
        padding: 4px 12px; border-top: 1px solid var(--border-color);
        display: flex; justify-content: space-between; align-items: center; min-height: 48px;
        flex-wrap: nowrap;
    }
    .footer-actions { display: flex; align-items: center; flex-wrap: nowrap; flex-shrink: 0;}
    .footer-actions button, #pin-modal-btn {
        background: transparent; border: none; border-radius: 50%;
        cursor: pointer; width: 36px; height: 36px;
        display: inline-flex; align-items: center; justify-content: center; color: var(--text-muted);
    }
    #modal-editor-header #pin-modal-btn { margin: 0 8px 0 4px; }

    .footer-actions button + button { margin-left: 4px; }
    .footer-actions button:hover, #pin-modal-btn:hover { background-color: var(--bg-tertiary); }
    .footer-actions button .material-icons, #pin-modal-btn .material-icons { font-size: 20px; }
    .footer-actions button.pinned .material-icons, #pin-modal-btn.pinned .material-icons { color: var(--text-primary); }
    .note-mod-date {
        font-size: 0.7em; color: var(--text-muted); flex-grow: 1; text-align: center; white-space: nowrap;
        overflow: hidden; text-overflow: ellipsis; min-width: 0;
    }
    #close-editor-link {
        font-weight: 500; padding: 8px 16px; border-radius: 4px; cursor: pointer;
        letter-spacing: .05em; color: var(--text-secondary); text-decoration: none;
        flex-shrink: 0; margin-left: 8px;
    }
    #close-editor-link:hover { background-color: var(--bg-tertiary); }


    #sidebar-menu {
      position: fixed; top: 0; left: 0; width: 280px; height: 100%;
      background-color: var(--bg-secondary); box-shadow: var(--shadow-lg); z-index: 1002; 
      transform: translateX(-100%); transition: transform 0.3s ease-in-out; 
      will-change: transform; display: flex; flex-direction: column;
      padding-top: 16px; border-right: 1px solid var(--border-color);
    }
    #sidebar-menu.open { transform: translateX(0); }
    
    #sidebar-menu li > a {
        display: flex; align-items: center; color: var(--text-primary);
        font-weight: 500; padding: 0 24px 0 16px; height: 48px;
        border-top-right-radius: 24px; border-bottom-right-radius: 24px;
    }
    .sidebar-item-count {
        margin-left: auto; color: var(--text-muted);
        font-size: 0.9em; font-weight: 400;
    }

    #sidebar-menu li > a > i.material-icons {
        margin-right: 28px; color: var(--text-secondary);
    }
    #sidebar-menu li > a.active { background-color: var(--primary-color); }
    #sidebar-menu li > a.active, #sidebar-menu li > a.active i.material-icons { color: #ffffff; }
    #sidebar-menu li > a.active .sidebar-item-count { color: #ffffff; font-weight: 500; }
     #sidebar-menu .tags-section-container .sidebar-content { padding: 0; }
    .sidebar-content ul#tags-list li a { padding: 10px 24px 10px 16px; height: 48px; }
    .sidenav-overlay { z-index: 1001 !important; }
    #sidebar-menu .sidebar-footer {
        margin-top: auto; text-align: center; padding: 20px 0;
        color: var(--text-muted); font-size: 0.8em;
    }
    #sidebar-menu .sidebar-footer a {
        color: inherit;
        text-decoration: none;
    }
    #sidebar-menu .sidebar-footer a:hover {
        text-decoration: underline;
    }

    .tooltip-inner {
        background-color: var(--bg-tertiary); color: var(--text-primary);
        border-radius: 4px; padding: 6px 10px; font-size: 13px;
        box-shadow: var(--shadow-md); border: 1px solid var(--border-color);
    }
    
    .note-card .pin-indicator {
        position: absolute; top: 8px; right: 8px; color: var(--text-muted);
        z-index: 1; font-size: 20px; display: none;
    }
    .note-card.pinned-note .pin-indicator { display: block; }

    .note-card .pin-toggle-btn {
        position: absolute; top: 2px; left: 2px; z-index: 3;
        background-color: transparent; border: none; color: var(--text-muted);
        padding: 8px; border-radius: 50%; cursor: pointer;
        opacity: 0; transition: opacity 0.2s ease-in-out, background-color 0.2s; line-height: 1;
    }
    .note-card:hover .pin-toggle-btn { opacity: 1; }
    .note-card .pin-toggle-btn:hover { background-color: var(--bg-tertiary); }
    .note-card .pin-toggle-btn .material-icons { font-size: 20px; display: block; }
    .note-card.pinned-note .pin-toggle-btn .material-icons,
    .note-card.pinned-note .pin-indicator { color: var(--text-primary); }

    .selection-overlay {
        position: absolute; top: -1px; left: -1px; width: 28px; height: 28px;
        background-color: var(--primary-color); border-radius: 50%;
        display: none; align-items: center; justify-content: center; z-index: 2;
        border: 2px solid var(--bg-secondary);
    }
    .selection-overlay .material-icons { color: white; font-size: 18px; }
    .note-card.selected .selection-overlay { display: flex; }
    .note-card.selected:hover .pin-toggle-btn { opacity: 0; }
    .note-card.selected { box-shadow: 0 0 0 2px var(--primary-color); }

    .note-card.keyboard-focused {
        box-shadow: var(--shadow-md), 0 0 0 2px var(--primary-color);
    }

    .dropdown-content {
        border-radius: 4px; box-shadow: var(--shadow-lg); background-color: var(--bg-tertiary);
    }
    .dropdown-content li>a, .dropdown-content li>span {
        color: var(--text-primary); font-size: 14px; padding: 10px 16px;
    }
    .dropdown-content li>a .material-icons, .dropdown-content li>span .material-icons {
        float: left;
        margin-right: 1rem;
        font-size: 1.2rem;
        color: var(--text-secondary);
    }
    .dropdown-content li:hover { background-color: var(--bg-secondary); }

    #help-modal .modal-content p, #help-modal .modal-content h4 { margin: 1em 0; }
    #help-modal .modal-content h4 { font-size: 1.2rem; }
    #help-modal .modal-content table { width: 100%; margin-bottom: 1.5em; }
    #help-modal .modal-content th { text-align: left; padding: 8px; border-bottom: 1px solid var(--border-color);}
    #help-modal .modal-content td { padding: 8px; vertical-align: middle;}
    #help-modal .modal-content kbd {
        background-color: var(--bg-tertiary); border-radius: 3px; border: 1px solid var(--border-color);
        box-shadow: 0 1px 1px rgba(0, 0, 0, .3), 0 2px 0 0 rgba(255, 255, 255, .1) inset;
        color: var(--text-secondary); display: inline-block; font-family: monospace;
        font-size: .85em; font-weight: 700; line-height: 1;
        padding: 4px 6px; white-space: nowrap;
    }
    
    #history-modal ul, #global-history-modal ul { list-style: none; padding: 0; margin-top: 1rem; max-height: 60vh; overflow-y: auto; text-align: left; }
    #history-modal li, #global-history-modal li { background-color: var(--bg-tertiary); margin-bottom: 0.5rem; border-radius: 4px; transition: background-color 0.2s; display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 1rem; }
    #history-modal li:hover, #global-history-modal li:hover { background-color: var(--bg-primary); }
    #history-modal li .version-date, #global-history-modal li .version-date { flex-grow: 1; color: var(--text-secondary); font-size: 0.9em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 10px;}

    #history-preview-modal-overlay { z-index: 1052; }
    #history-preview-modal { z-index: 1053; }
    #history-preview-content {
        padding: 15px; border: 1px solid var(--border-color);
        background-color: var(--bg-primary);
        max-height: 60vh; overflow-y: auto;
    }
    
    #modal-editor-container.light-bg { color: #202124; }
    #modal-editor-container.light-bg #modal-note-title-input,
    #modal-editor-container.light-bg #note-editor-contenteditable,
    #modal-editor-container.light-bg #close-editor-link,
    #modal-editor-container.light-bg .note-mod-date,
    #modal-editor-container.light-bg #pin-modal-btn,
    #modal-editor-container.light-bg .footer-actions button { color: #202124; }
    #modal-editor-container.light-bg #modal-note-title-input::placeholder { color: rgba(0,0,0,0.6); }

    #modal-editor-container.light-bg #modal-editor-header { border-bottom-color: rgba(0,0,0,0.2); }
    #modal-editor-container.light-bg .modal-editor-footer { background-color: transparent; border-color: rgba(0,0,0,0.2); }
    #modal-editor-container.light-bg #close-editor-link:hover,
    #modal-editor-container.light-bg .footer-actions button:hover,
    #modal-editor-container.light-bg #pin-modal-btn:hover { background-color: rgba(0,0,0,0.1); }


    #modal-editor-container.dark-bg { color: #e8eaed; }
    #modal-editor-container.dark-bg #modal-note-title-input,
    #modal-editor-container.dark-bg #note-editor-contenteditable,
    #modal-editor-container.dark-bg #close-editor-link,
    #modal-editor-container.dark-bg .note-mod-date,
    #modal-editor-container.dark-bg #pin-modal-btn,
    #modal-editor-container.dark-bg .footer-actions button { color: #e8eaed; }
    #modal-editor-container.dark-bg #modal-note-title-input::placeholder { color: rgba(255,255,255,0.6); }

    #modal-editor-container.dark-bg #modal-editor-header { border-bottom-color: rgba(255,255,255,0.2); }
    #modal-editor-container.dark-bg .modal-editor-footer { background-color: transparent; border-color: rgba(255,255,255,0.2); }
    #modal-editor-container.dark-bg #close-editor-link:hover,
    #modal-editor-container.dark-bg .footer-actions button:hover,
    #modal-editor-container.dark-bg #pin-modal-btn:hover { background-color: rgba(255,255,255,0.1); }

    #tag-suggestion-popup {
        position: absolute; background-color: var(--bg-secondary);
        border: 1px solid var(--border-color); box-shadow: var(--shadow-lg);
        border-radius: 8px; z-index: 1050; width: 280px; max-height: 350px;
        display: flex; flex-direction: column;
    }
    .tag-suggestion-header {
        padding: 12px 16px; font-weight: 500; font-size: 1rem;
        color: var(--text-primary); border-bottom: 1px solid var(--border-color);
        flex-shrink: 0;
    }
    #tag-suggestion-popup .input-field { flex-shrink: 0; }
    #tag-suggestion-popup .input-field input { color: var(--text-primary); }
    #tag-suggestion-popup .input-field input::placeholder { color: var(--text-muted); }

    #tag-suggestion-list {
        list-style: none; padding: 8px 0; margin: 0; overflow-y: auto; flex-grow: 1;
    }
    #tag-suggestion-list li.tag-item label {
        display: flex; align-items: center; padding: 8px 16px;
        cursor: pointer; font-size: 14px; color: var(--text-secondary);
        transition: background-color: 0.2s ease; width: 100%;
    }
    #tag-suggestion-list li.tag-item label:hover { background-color: var(--bg-tertiary); }
    #tag-suggestion-list [type="checkbox"].filled-in+span:not(.lever) {
        padding-left: 35px; color: inherit; font-family: 'Roboto', sans-serif;
    }
    #tag-suggestion-list .create-new-tag-option {
        padding: 8px 16px; cursor: pointer; font-size: 14px;
        color: var(--accent-color); display: flex; align-items: center;
    }
    #tag-suggestion-list .create-new-tag-option .material-icons {
        font-size: 1.2rem; margin-right: 8px;
    }
    #tag-suggestion-list .create-new-tag-option:hover { background-color: var(--bg-tertiary); }
    
    #edit-tags-modal-overlay, #help-modal-overlay, #create-table-modal-overlay, #history-modal-overlay, #global-history-modal-overlay, #history-preview-modal-overlay, #encrypt-modal-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.6); z-index: 1050;
    }
    #edit-tags-modal, #help-modal, #create-table-modal, #history-modal, #global-history-modal, #history-preview-modal, #encrypt-modal {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        width: 90%; max-width: 500px;
        background-color: var(--bg-secondary); color: var(--text-primary);
        border-radius: var(--border-radius); box-shadow: var(--shadow-lg);
        z-index: 1051; display: flex; flex-direction: column; max-height: 80vh;
    }
    #global-history-modal { max-width: 800px; }
    #create-table-modal, #encrypt-modal { max-width: 320px; }
    #history-preview-modal { max-width: 800px; }
    #edit-tags-modal .modal-header, #help-modal .modal-header, #create-table-modal .modal-header, #history-modal .modal-header, #global-history-modal .modal-header, #history-preview-modal .modal-header, #encrypt-modal .modal-header {
        padding: 16px 24px; border-bottom: 1px solid var(--border-color);
        display: flex; justify-content: space-between; align-items: center;
    }
    #edit-tags-modal .modal-header h3, #help-modal .modal-header h3, #create-table-modal .modal-header h3, #history-modal .modal-header h3, #global-history-modal .modal-header h3, #history-preview-modal .modal-header h3, #encrypt-modal .modal-header h3 { margin: 0; font-size: 1.25rem; }
    #edit-tags-modal .modal-content, #help-modal .modal-content, #create-table-modal .modal-content, #history-modal .modal-content, #global-history-modal .modal-content, #history-preview-modal .modal-content, #encrypt-modal .modal-content { flex-grow: 1; overflow-y: auto; padding: 24px; }
    #edit-tags-modal .modal-footer, #help-modal .modal-footer, #create-table-modal .modal-footer, #history-modal .modal-footer, #global-history-modal .modal-footer, #history-preview-modal .modal-footer, #encrypt-modal .modal-footer { padding: 8px 16px; border-top: 1px solid var(--border-color); text-align: right; }
    #edit-tags-modal .modal-footer a, #help-modal .modal-footer a, #create-table-modal .modal-footer a, #history-modal .modal-footer a, #global-history-modal .modal-footer a, #history-preview-modal .modal-footer a, #encrypt-modal .modal-footer a { font-weight: 500; padding: 8px 16px; border-radius: 4px; cursor: pointer; color: var(--text-secondary); text-decoration: none;}
    #edit-tags-modal .modal-footer a:hover, #help-modal .modal-footer a:hover, #create-table-modal .modal-footer a:hover, #history-modal .modal-footer a:hover, #global-history-modal .modal-footer a:hover, #history-preview-modal .modal-footer a:hover, #encrypt-modal .modal-footer a:hover { background-color: var(--bg-tertiary); }
    #global-history-modal .modal-footer { display: flex; justify-content: space-between; align-items: center; }
    #edit-tags-modal .create-tag-section, #editable-tags-list li {
        display: flex; align-items: center; padding: 8px 24px; min-height: 48px;
    }
    #edit-tags-modal .modal-content { padding: 0; }
    #edit-tags-modal .create-tag-section { border-bottom: 1px solid var(--border-color); }
    #edit-tags-modal .create-tag-section .material-icons, #editable-tags-list li .material-icons {
        color: var(--text-muted); cursor: pointer;
    }
    #edit-tags-modal .create-tag-section input {
        flex-grow: 1; border: none; outline: none; margin: 0 16px;
        font-size: 1rem; background: transparent; height: auto; color: var(--text-primary);
    }
    #editable-tags-list { list-style: none; margin: 0; padding: 8px 0; }
    #editable-tags-list li .tag-name-container { flex-grow: 1; display: flex; align-items: center; }
    #editable-tags-list li .tag-name-container .material-icons { margin-right: 16px; }
    #editable-tags-list li .tag-name, #editable-tags-list li .tag-edit-input {
        flex-grow: 1; margin: 0; font-size: 1rem;
    }
    #editable-tags-list li .tag-edit-input {
        border: none; outline: none; background: transparent; color: inherit;
        border-bottom: 1px solid var(--primary-color); padding: 4px 0; height: auto;
    }
    
    #global-history-pagination {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    ul.checklist {
        list-style-type: none !important; padding-left: 5px !important; margin: 0.75em 0 !important;
    }
    ul.checklist li {
        display: flex; align-items: flex-start;
        padding-left: 0 !important; margin-bottom: 6px; position: relative;
    }
    ul.checklist li::before { content: none !important; }
    ul.checklist li .checklist-box {
        cursor: pointer; margin-right: 12px;
        font-size: 20px; user-select: none; margin-top: 2px;
    }
    ul.checklist li .checklist-text { flex-grow: 1; outline: none; line-height: 1.5; }
    ul.checklist li.completed > .checklist-text {
        text-decoration: line-through; color: var(--text-muted);
    }
    .reorder-handles {
        display: none; position: absolute; right: 0; top: 0; cursor: pointer;
        background-color: var(--bg-tertiary); border-radius: 4px; align-items: center;
    }
    #note-editor-contenteditable.reorder-mode .reorder-handles { display: flex; }
    .reorder-handles i { font-size: 18px; padding: 2px; }
    
    #dictationModal, #improveModal {
        display: none; position: fixed; top: 0; left: 0;
        width: 100%; height: 100%; z-index: 1060;
        background-color: var(--bg-primary); padding: 0;
        overflow: hidden; text-align: left;
    }
    #dictationModal .app-header, #improveModal .app-header {
        background-color: var(--surface-color); padding: 10px; display: flex;
        align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px;
        border-bottom: 1px solid var(--border-color);
    }
    #dictationModal .app-header h3, #improveModal .app-header h3 { font-size: 1.2em; font-weight: 500; margin: 0; }
    #dictationModal .editor-container, #improveModal .editor-container {
        height: calc(100% - 70px); overflow-y: auto;
        padding: 15px; background-color: transparent;
    }
    #dictationModal .control-group, #improveModal .control-group { margin-bottom: 20px; border-bottom: 1px solid var(--border-color); padding-bottom: 20px; }
    #dictationModal .control-group:last-child, #improveModal .control-group:last-child { border-bottom: none; }
    #dictationModal label, #improveModal label { display: block; margin-bottom: 8px; font-weight: 500; font-size: 0.9em; }
    #dictationModal textarea, #improveModal textarea {
        width: 100%; background-color: var(--input-background); color: var(--text-primary);
        font-size: 0.95rem; border-radius: 8px; padding: 10px; border: 1px solid var(--border-color);
        resize: vertical; min-height: 120px;
    }
    #dictationModal .button-toolbar, #improveModal .button-toolbar { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
    #dictationModal .btn, #improveModal .btn, .ai-modal-btn {
        background-color: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color);
        padding: 8px 12px; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.85rem;
        display: inline-flex; align-items: center; gap: 6px; text-transform: none; height: auto;
    }
    #dictationModal .btn.btn-primary, #improveModal .btn.btn-primary { background-color: var(--primary-color); color: white; border-color: var(--primary-color);}
    #dictationModal .btn.btn-danger, #improveModal .btn.btn-danger { background-color: var(--danger-color); color: white; border-color: var(--danger-color); }
    #dictationModal .ia-settings, #improveModal .ia-settings { margin-top: 15px; display: flex; gap: 15px; flex-wrap: wrap; }
    #dictationModal .selector-group, #improveModal .selector-group { flex: 1; min-width: 200px; }
    #dictationModal .selector-group select, #improveModal .selector-group select {
        width: 100%; padding: 10px; font-size: 0.9rem; border-radius: 6px; border: 1px solid var(--border-color);
        background-color: var(--input-background); color: var(--text-primary);
    }
    
    .llm-selector-overlay { display: none; position: fixed; z-index: 2200; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); backdrop-filter: blur(5px); align-items: center; justify-content: center; }
    .llm-selector-overlay.show { display: flex; }
    .llm-selector-modal { background-color: var(--bg-secondary); color: var(--text-primary); margin: auto; padding: 20px; border: 1px solid var(--border-color); width: 90%; max-width: 500px; border-radius: 8px; box-shadow: var(--shadow-lg); position: relative; animation: fadeIn 0.3s; }
    @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
    .llm-selector-close { color: var(--text-muted); position: absolute; top: 10px; right: 15px; font-size: 28px; font-weight: bold; background: none; border: none; cursor: pointer; }
    .llm-selector-close:hover, .llm-selector-close:focus { color: var(--text-primary); }
    .llm-selector-modal h2 { margin-top: 0; margin-bottom: 15px; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
    #llmModelSelect, #llmProviderSelect, #llmSaveButton { width: 100%; padding: 10px; margin-top: 15px; border-radius: 6px; border: 1px solid var(--border-color); background-color: var(--input-background); color: var(--text-primary); font-size: 1rem; }
    #llmSaveButton { background-color: var(--success-color); color: white; cursor: pointer; font-weight: bold; }
    #llmSaveButton:hover { opacity: 0.9; }

    /* --- List View Styles --- */
    #notes-grid-container.list-view {
        column-count: 1;
        display: flex;
        flex-direction: column;
        gap: 0;
    }
    .list-view .note-card {
        display: flex;
        flex-direction: row;
        align-items: baseline;
        width: 100%;
        margin-bottom: 0;
        background: transparent;
        border-radius: 0;
        border: none;
        border-bottom: 1px solid var(--border-color);
        box-shadow: none;
        padding: 10px 15px;
        break-inside: auto;
        transition: background-color 0.2s;
    }
    .list-view .note-card:hover {
        background-color: var(--bg-tertiary);
        transform: none;
        box-shadow: none;
    }
    .list-view .note-card.keyboard-focused {
        box-shadow: 2px 0 0 0 var(--primary-color) inset;
        background-color: var(--bg-tertiary);
    }
    .list-view .note-card > :not(span) {
        display: none;
    }
    .list-view-bullet {
        color: var(--primary-color);
        margin-right: 12px;
        font-weight: bold;
    }
    .list-view .note-card.pinned-note .list-view-bullet {
        color: yellow;
    }
    .list-view-title {
        flex-grow: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        color: var(--text-primary);
    }
    .list-view-separator {
        margin: 0 10px;
        color: var(--text-muted);
    }
    .list-view-date {
        flex-shrink: 0;
        font-size: 0.85em;
        color: var(--text-muted);
    }
    
    /* --- Wikilink Styles --- */
    a.internal-link {
        color: var(--primary-color); text-decoration: none;
        background-color: rgba(99, 102, 241, 0.15);
        border-radius: 3px; padding: 0 2px;
    }
    a.internal-link:hover { background-color: rgba(99, 102, 241, 0.3); }
    a.internal-link-broken {
        color: var(--danger-color); text-decoration: none;
        border-bottom: 1px dashed var(--danger-color);
    }
    
    /* --- Autocomplete Popup Styles --- */
    #wikilink-popup {
        position: absolute; background-color: var(--bg-secondary);
        border: 1px solid var(--border-color); box-shadow: var(--shadow-lg);
        border-radius: 4px; z-index: 1100; max-height: 200px;
        overflow-y: auto; min-width: 200px;
    }
    #wikilink-popup ul { list-style: none; padding: 4px 0; margin: 0; }
    #wikilink-popup li { padding: 8px 16px; cursor: pointer; font-size: 0.9em; color: var(--text-secondary);}
    #wikilink-popup li:hover, #wikilink-popup li.selected { background-color: var(--bg-tertiary); color: var(--text-primary); }

    /* --- Links Container Styles (Backlinks/Forward Links) --- */
    .links-container {
        margin-top: 24px;
        padding-top: 16px;
        border-top: 1px solid var(--border-color);
        font-size: 0.9em;
        color: var(--text-secondary);
    }
    .links-container h4 {
        font-size: 1rem;
        font-weight: 500;
        color: var(--text-muted);
        margin: 0 0 8px 0;
    }
    .links-container ul {
        list-style: none;
        padding: 0;
        margin: 0 0 16px 0;
    }
    .links-container li {
        margin-bottom: 4px;
    }


    /* --- Attachments --- */
    .note-attachments-container {
      margin-top: 20px; padding-top: 10px; border-top: 1px solid var(--border-color);
    }
    .attachment-item {
        display: inline-flex; align-items: center; background-color: var(--bg-tertiary);
        border-radius: 16px; padding: 5px 12px; margin: 4px; font-size: 0.9em;
    }
    .attachment-item a { text-decoration: none; color: var(--text-secondary); }
    .attachment-item a:hover { color: var(--text-primary); }
    .attachment-item .material-icons { font-size: 1.1em; margin-right: 6px; }

    /* Sidebar Tag Filter */
    #tag-filter-container {
        padding: 0 16px 8px 16px;
    }
    #tag-filter-input {
        width: 100%;
        background-color: var(--bg-primary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        color: var(--text-primary);
        padding: 6px 12px;
        font-size: 0.9em;
    }
    #tag-filter-input:focus {
        outline: none;
        border-color: var(--primary-color);
    }

    /* Table Styles */
    #note-editor-contenteditable table {
        border-collapse: collapse;
        width: 100%;
    }
    #note-editor-contenteditable th, #note-editor-contenteditable td {
        border: 1.5px solid var(--border-color) !important;
        padding: 8px;
    }
    #note-editor-contenteditable th {
        background-color: var(--bg-tertiary);
    }

    /* Image Resize Controls */
    #image-resize-controls {
        position: absolute;
        z-index: 1101;
        background-color: var(--bg-secondary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        box-shadow: var(--shadow-lg);
        padding: 8px;
        display: none;
        align-items: center;
        gap: 8px;
    }
    #image-resize-controls input[type="range"] {
        width: 120px;
        margin: 0;
    }
    #image-resize-controls label {
        font-size: 0.8em;
        color: var(--text-secondary);
    }
    #image-resize-controls .btn-small {
        padding: 0 1rem;
    }

    /* Pagination Styles */
    #pagination-container .pagination {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding-left: 0;
        margin: 20px 0;
        border-radius: 4px;
    }
    #pagination-container .pagination li {
        display: inline-block;
    }
    #pagination-container .pagination li a {
        color: var(--text-secondary);
        background-color: transparent;
        border: none;
        padding: 8px;
        border-radius: 50%;
        line-height: 1;
        display: inline-flex;
        align-items: center;
        justify-content: center;
    }
    #pagination-container .pagination li.waves-effect a:hover {
        background-color: var(--bg-tertiary);
    }
    #pagination-container .pagination li.disabled a {
        color: var(--text-muted);
        cursor: not-allowed;
        background-color: transparent;
    }
    #pagination-container .pagination li.page-info {
        color: var(--text-muted);
        padding: 0 12px;
        font-size: 0.9em;
    }

    /* Progress Indicator Styles */
    #progress-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(2px);
        z-index: 2000;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    
    /* Embed Card Styles */
    .embed-card {
        background-color: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 12px;
        margin: 1em 0;
        box-shadow: var(--shadow-sm);
    }
    .embed-card iframe {
        width: 100%;
        border: none;
        border-radius: 4px;
        aspect-ratio: 16 / 9;
        height: auto;
    }
    .embed-meta {
        margin-top: 8px;
    }
    .embed-title {
        font-weight: 600;
        font-size: 1.1em;
        color: var(--text-primary);
    }
    .embed-author {
        font-size: 0.9em;
        color: var(--text-secondary);
        margin-top: 4px;
    }


    @media (max-width: 768px) {
        #universal-note-input { font-size: 1.1rem; }
        #universal-note-input::placeholder { font-size: 1.1rem; }
        #modal-editor-container { width: 95%; }
    }
    @media (max-width: 600px) {
      body { padding-top: 65px; }
      #top-action-bar, #multi-select-action-bar { height: 48px; padding: 6px 10px; margin: 10px; }
      .main-container { padding: 0 10px 10px 10px; }
      #modal-editor-container {
        width: 100%; height: 100%; max-height: 100%;
        top: 0; left: 0; transform: none; border-radius: 0;
      }
      .modal-editor-footer {
          flex-direction: row;
          flex-wrap: nowrap;
          align-items: center;
          padding: 4px 8px;
      }
      .note-mod-date {
          order: 0;
          width: auto;
          margin-bottom: 0;
          flex-shrink: 1;
          min-width: 0;
      }
      .mod-date-date, .mod-date-time {
          display: block;
          line-height: 1.1;
      }
      .mod-date-date { font-size: 0.85em; }
      .mod-date-time { font-size: 0.75em; }

      .footer-actions {
        justify-content: space-between;
        width: auto;
        flex-shrink: 0;
      }
      .footer-actions button, #pin-modal-btn {
          width: 32px;
          height: 32px;
      }
       .footer-actions button .material-icons, #pin-modal-btn .material-icons {
          font-size: 18px;
      }
    }
  </style>
</head>
<body>
    <div id="progress-overlay" class="hidden">
      <div class="preloader-wrapper big active">
        <div class="spinner-layer spinner-blue-only">
          <div class="circle-clipper left">
            <div class="circle"></div>
          </div><div class="gap-patch">
            <div class="circle"></div>
          </div><div class="circle-clipper right">
            <div class="circle"></div>
          </div>
        </div>
      </div>
    </div>

    <input type="color" id="custom-color-picker" style="display: none;">
    <input type="file" id="file-attachment-input" style="display: none;">
    <input type="file" id="camera-input" accept="image/*" capture="environment" style="display: none;">

    <ul id="sidebar-menu" class="sidenav">
        <li><a href="#!" id="all-notes-btn" class="waves-effect"><i class="material-icons">lightbulb_outline</i>Notas <span class="sidebar-item-count" id="all-notes-count"></span></a></li>
        <li><div class="divider"></div></li>
        <li class="tags-section-container">
            <div id="tag-filter-container">
                <input type="text" id="tag-filter-input" placeholder="Filtrar etiquetas...">
            </div>
            <div class="sidebar-content">
                 <ul id="tags-list">
                 </ul>
            </div>
        </li>
        <li><a href="#!" id="untagged-notes-btn" class="waves-effect"><i class="material-icons">label_off</i>Notas sin etiqueta</a></li>
        <li><div class="divider"></div></li>
        <li><a href="#!" id="edit-tags-sidebar-btn" class="waves-effect"><i class="material-icons">edit</i>Editar etiquetas</a></li>
        <li><a href="#!" id="archive-btn" class="waves-effect"><i class="material-icons">archive</i>Notas archivadas <span class="sidebar-item-count" id="archive-count"></span></a></li>
        <li><a href="#!" id="trash-btn" class="waves-effect"><i class="material-icons">delete</i>Papelera <span class="sidebar-item-count" id="trash-count"></span></a></li>
        <li class="sidebar-footer">
            <div><a href="https://github.com/uGeek/wdnotes" target="_blank" rel="noopener noreferrer">wdnotes © uGeek. 2025</a></div>
        </li>
    </ul>

  <div id="multi-select-action-bar">
    <div class="selection-info">
        <button id="close-selection-btn" title="Cancelar selección"><i class="material-icons">close</i></button>
        <span id="selection-count"></span>
    </div>
    <div class="actions">
        <button data-action="multi-pin" title="Fijar"><i class="material-icons">push_pin</i></button>
        <button data-action="multi-color" title="Cambiar color"><i class="material-icons">palette</i></button>
        <button data-action="multi-tag" title="Añadir etiqueta"><i class="material-icons">local_offer</i></button>
        <button data-action="multi-archive" title="Archivar"><i class="material-icons">archive</i></button>
        <button data-action="multi-trash" title="Mover a papelera"><i class="material-icons">delete</i></button>
        <!-- NEW REORDER BUTTONS -->
        <span id="multi-reorder-separator" class="hidden" style="border-left: 1px solid var(--border-color); margin: 0 8px;"></span>
        <button data-action="multi-reorder-up" title="Mover arriba" class="hidden"><i class="material-icons">arrow_upward</i></button>
        <button data-action="multi-reorder-down" title="Mover abajo" class="hidden"><i class="material-icons">arrow_downward</i></button>
    </div>
  </div>

  <div id="top-action-bar">
    <button id="hamburger-menu-btn" title="Menú" data-target="sidebar-menu" class="sidenav-trigger"><i class="material-icons">menu</i></button>
    <input type="text" id="universal-note-input" placeholder="Filtrar o crear nota...">
    <div class="top-bar-actions">
      <button id="clear-filter-btn" title="Limpiar filtro" class="tooltipped" data-position="bottom" data-tooltip="Limpiar"><i class="material-icons">clear</i></button>
      <button id="create-note-icon-btn" title="Crear nueva nota" class="tooltipped" data-position="bottom" data-tooltip="Crear"><i class="material-icons">add_circle_outline</i></button>
      <button id="jump-to-note-btn" title="Saltar a siguiente nota" class="tooltipped" data-position="bottom" data-tooltip="Siguiente"><i class="material-icons">arrow_downward</i></button>
      <button id="refresh-notes-icon-btn" title="Actualizar lista" class="tooltipped" data-position="bottom" data-tooltip="Actualizar"><i class="material-icons">refresh</i></button>
      <button id="settings-btn" class="dropdown-trigger" data-target="settings-dropdown" title="Ajustes"><i class="material-icons">settings</i></button>
      <ul id="settings-dropdown" class="dropdown-content">
        <li><a href="#!" id="toggle-theme-btn">Tema Oscuro</a></li>
        <li><a href="#!" id="global-history-btn"><i class="material-icons">history</i>Historial Global</a></li>
        <li><a href="#!" id="toggle-mode-btn"></a></li>
        <li><a href="#!" id="toggle-view-btn"></a></li>
        <div id="other-books-container"></div>
      </ul>
    </div>
  </div>

  <div id="notes-view-container" class="main-container">
    <p id="notes-count"></p>
    <p id="trash-info-message" class="hidden"></p>
    <div id="loading-indicator" class="hidden">Cargando notas...</div>
    <div id="notes-grid-container"></div>
    <div id="pagination-container" style="display: none; text-align: center; padding: 20px 0;"></div>
  </div>

  <div id="modal-overlay" class="hidden"></div>
  <div id="modal-editor-container" class="hidden">
    <div id="modal-editor-header">
      <button id="pin-modal-btn" class="tooltipped" data-position="bottom" data-tooltip="Fijar"><i class="material-icons">push_pin</i></button>
      <input type="text" id="modal-note-title-input" placeholder="Título">
      <a id="close-editor-link">Cerrar</a>
    </div>
    <div id="note-editor-wrapper">
        <div id="note-editor-contenteditable" contenteditable="true"></div>
        <div id="note-editor-preview" class="hidden"></div>
    </div>
    <div class="modal-editor-footer">
        <div class="footer-actions">
            <button id="add-checklist-modal-btn" class="tooltipped" data-position="top" data-tooltip="Añadir checklist"><i class="material-icons">check_box</i></button>
            <button id="reorder-checklist-btn" class="tooltipped" data-position="top" data-tooltip="Ordenar tareas"><i class="material-icons">sort</i></button>
            <button id="markdown-toggle-btn" class="tooltipped" data-position="top" data-tooltip="Modo Markdown"><i class="material-icons">code</i></button>
        </div>
        <div id="markdown-view-controls" class="footer-actions hidden">
            <button id="md-view-prev-btn" class="tooltipped" data-position="top" data-tooltip="Vista anterior"><i class="material-icons">chevron_left</i></button>
            <button id="md-view-next-btn" class="tooltipped" data-position="top" data-tooltip="Siguiente vista"><i class="material-icons">chevron_right</i></button>
        </div>
        <span id="note-mod-date" class="note-mod-date"></span>
        <div class="footer-actions">
            <button id="archive-modal-btn" class="tooltipped" data-position="top" data-tooltip="Archivar"><i class="material-icons">archive</i></button>
            <button id="manage-tags-modal-btn" class="tooltipped" data-position="top" data-tooltip="Etiquetas"><i class="material-icons">local_offer</i></button>
            <button id="trash-modal-btn" class="tooltipped" data-position="top" data-tooltip="Mover a papelera"><i class="material-icons">delete_outline</i></button>
            <button id="more-options-modal-btn" class="dropdown-trigger tooltipped" data-target="more-options-dropdown" data-position="top" data-tooltip="Más opciones"><i class="material-icons">more_vert</i></button>
            <ul id="more-options-dropdown" class="dropdown-content">
                <li><a href="#!" id="add-camera-option"><i class="material-icons">photo_camera</i>Insertar foto</a></li>
                <li><a href="#!" id="change-color-option"><i class="material-icons">palette</i>Color</a></li>
                <li><a href="#!" id="clean-format-option"><i class="material-icons">format_clear</i>Limpiar formato</a></li>
                <li class="divider" tabindex="-1"></li>
                <li id="add-file-option-li"><a href="#!" id="add-file-option"><i class="material-icons">attach_file</i>Adjuntar archivo</a></li>
                <li id="add-table-option-li"><a href="#!" id="add-table-option"><i class="material-icons">table_chart</i>Insertar tabla</a></li>
                <li><a href="#!" id="copy-as-text-option"><i class="material-icons">content_paste</i>Copiar como texto</a></li>
                <li id="duplicate-note-option-li"><a href="#!" id="duplicate-note-option"><i class="material-icons">content_copy</i>Crear una copia</a></li>
                <li><a class="dropdown-trigger" href="#!" data-target="move-modal-dropdown"><i class="material-icons">drive_file_move</i>Mover nota</a></li>
                <li class="divider" tabindex="-1"></li>
                <li id="dictation-option-li"><a href="#!" id="dictation-option"><i class="material-icons">mic</i>Dictado por Voz</a></li>
                <li id="improve-note-option-li"><a href="#!" id="improve-note-option"><i class="material-icons">auto_awesome</i>Mejorar Nota por IA</a></li>
                 <li id="encrypt-decrypt-option-li"><a href="#!" id="encrypt-decrypt-option"><i class="material-icons">lock_outline</i>Cifrar</a></li>
                <li id="edit-encrypted-option-li" style="display: none;"><a href="#!" id="edit-encrypted-option"><i class="material-icons">lock_open</i>Editar Cifrado</a></li>
                <li id="history-option-li"><a href="#!" id="history-option"><i class="material-icons">history</i>Historial de versiones</a></li>
            </ul>
             <ul id="move-modal-dropdown" class="dropdown-content">
                <!-- Populated by JS -->
            </ul>
            <button id="fullscreen-modal-btn" class="tooltipped" data-position="top" data-tooltip="Pantalla completa"><i class="material-icons">fullscreen</i></button>
        </div>
    </div>
  </div>
  
  <div id="edit-tags-modal-overlay" class="hidden"></div>
  <div id="edit-tags-modal" class="hidden">
      <div class="modal-header">
          <h3>Editar etiquetas</h3>
      </div>
      <div class="modal-content">
          <div class="create-tag-section">
              <i class="material-icons" id="clear-create-tag-btn" style="cursor: pointer;">close</i>
              <input type="text" id="create-tag-modal-input" placeholder="Crear etiqueta">
              <i class="material-icons" id="confirm-create-tag-btn" style="cursor: pointer;">done</i>
          </div>
          <ul id="editable-tags-list">
          </ul>
      </div>
      <div class="modal-footer">
          <a href="#!" id="close-edit-tags-modal-btn">HECHO</a>
      </div>
  </div>

  <div id="help-modal-overlay" class="hidden"></div>
  <div id="help-modal" class="hidden">
      <div class="modal-header">
          <h3>Ayuda y Atajos de Teclado</h3>
      </div>
      <div class="modal-content">
          <p>Esta es una aplicación simple de notas que guarda los archivos en formato HTML en un servidor WebDAV.</p>
          <h4>Atajos Globales</h4>
          <table>
              <thead>
                  <tr><th>Acción</th><th>Atajo</th></tr>
              </thead>
              <tbody>
                  <tr><td>Buscar / Crear Nota</td><td><kbd>Ctrl</kbd> + <kbd>F</kbd></td></tr>
                  <tr><td>Navegar entre notas</td><td><kbd>Ctrl</kbd> + <kbd>Flechas</kbd></td></tr>
                  <tr><td>Abrir nota seleccionada</td><td><kbd>Ctrl</kbd> + <kbd>Enter</kbd></td></tr>
                  <tr><td>Guardar Nota (en editor)</td><td><kbd>Ctrl</kbd> + <kbd>S</kbd></td></tr>
                  <tr><td>Cerrar Editor de Nota</td><td><kbd>Ctrl</kbd> + <kbd>Q</kbd> o <kbd>Esc</kbd></td></tr>
                   <tr><td>Seleccionar Modelo IA</td><td><kbd>Ctrl</kbd> + <kbd>L</kbd></td></tr>
                  <tr><td>Mostrar esta ayuda</td><td><kbd>Ctrl</kbd> + <kbd>H</kbd></td></tr>
              </tbody>
          </table>
          <h4>Atajos en el Editor de Notas</h4>
          <table>
              <thead>
                  <tr><th>Acción</th><th>Atajo</th></tr>
              </thead>
              <tbody>
                  <tr><td>Negrita</td><td><kbd>Ctrl</kbd> + <kbd>B</kbd></td></tr>
                  <tr><td>Cursiva</td><td><kbd>Ctrl</kbd> + <kbd>I</kbd></td></tr>
                  <tr><td>Subrayado</td><td><kbd>Ctrl</kbd> + <kbd>U</kbd></td></tr>
                  <tr><td>Título 1 / 2 / 3 / 4</td><td><kbd>Ctrl</kbd> + <kbd>1...4</kbd></td></tr>
                  <tr><td>Bloque de Código</td><td><kbd>Ctrl</kbd> + <kbd>K</kbd></td></tr>
                  <tr><td>Salto de línea en bloque de código</td><td><kbd>Shift</kbd> + <kbd>Enter</kbd></td></tr>
                  <tr><td>Lista Desordenada</td><td><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>7</kbd></td></tr>
                  <tr><td>Lista Ordenada</td><td><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>8</kbd></td></tr>
                  <tr><td>Insertar Tabla</td><td><kbd>Ctrl</kbd> + <kbd>T</kbd></td></tr>
              </tbody>
          </table>
      </div>
      <div class="modal-footer">
          <a href="#!" id="close-help-modal-btn">CERRAR</a>
      </div>
  </div>

  <div id="history-modal-overlay" class="hidden"></div>
  <div id="history-modal" class="hidden">
      <div class="modal-header">
          <h3>Historial de Versiones</h3>
      </div>
      <div class="modal-content">
          <div id="history-container">Cargando...</div>
      </div>
      <div class="modal-footer">
          <a href="#!" id="close-history-modal-btn">CERRAR</a>
      </div>
  </div>

  <div id="global-history-modal-overlay" class="hidden"></div>
  <div id="global-history-modal" class="hidden">
      <div class="modal-header">
          <h3>Historial de Versiones Global</h3>
      </div>
      <div class="modal-content">
          <div id="global-history-container">Cargando...</div>
      </div>
      <div class="modal-footer">
          <div id="global-history-pagination"></div>
          <div class="bulk-delete-actions">
              <a class="dropdown-trigger btn-flat" href="#" data-target="delete-older-dropdown">Borrar Antiguos</a>
              <ul id="delete-older-dropdown" class="dropdown-content">
                  <li><a href="#!" data-days="7">Más de 7 días</a></li>
                  <li><a href="#!" data-days="15">Más de 15 días</a></li>
                  <li><a href="#!" data-days="30">Más de 30 días</a></li>
                  <li><a href="#!" data-days="60">Más de 60 días</a></li>
                  <li><a href="#!" data-days="90">Más de 90 días</a></li>
                </ul>
          </div>
          <a href="#!" id="close-global-history-modal-btn">CERRAR</a>
      </div>
  </div>

  <div id="history-preview-modal-overlay" class="hidden"></div>
  <div id="history-preview-modal" class="hidden">
      <div class="modal-header">
          <h3>Vista Previa de Versión</h3>
      </div>
      <div class="modal-content">
          <div id="history-preview-content"></div>
      </div>
      <div class="modal-footer">
          <a href="#!" id="close-history-preview-modal-btn">CERRAR</a>
      </div>
  </div>

  <div id="create-table-modal-overlay" class="hidden"></div>
  <div id="create-table-modal" class="hidden">
      <div class="modal-header">
          <h3>Crear Tabla</h3>
      </div>
      <div class="modal-content">
          <div class="input-field">
              <input id="table-rows-input" type="number" value="3" min="1">
              <label for="table-rows-input" class="active">Filas</label>
          </div>
          <div class="input-field">
              <input id="table-cols-input" type="number" value="3" min="1">
              <label for="table-cols-input" class="active">Columnas</label>
          </div>
      </div>
      <div class="modal-footer">
          <a href="#!" id="cancel-create-table-btn">CANCELAR</a>
          <a href="#!" id="confirm-create-table-btn">CREAR</a>
      </div>
  </div>

  <div id="encrypt-modal-overlay" class="hidden"></div>
  <div id="encrypt-modal" class="hidden">
      <div class="modal-header">
          <h3 id="encrypt-modal-title">Cifrar Nota</h3>
      </div>
      <div class="modal-content">
          <div class="input-field">
              <input id="encrypt-password-input" type="password">
              <label for="encrypt-password-input">Contraseña</label>
          </div>
      </div>
      <div class="modal-footer">
          <a href="#!" id="cancel-encrypt-btn">CANCELAR</a>
          <a href="#!" id="confirm-encrypt-btn">ACEPTAR</a>
      </div>
  </div>
  
  <div id="dictationModal">
      <div class="app-header">
          <h3><i class="fas fa-microphone-alt"></i> Editor de Dictado y IA</h3>
          <div class="main-controls">
              <button id="dictation-saveButton" class="btn btn-primary ai-modal-btn"><i class="fas fa-save"></i> Guardar en Nota</button>
              <button id="dictation-closeButton" class="btn btn-danger ai-modal-btn"><i class="fas fa-times"></i></button>
          </div>
      </div>
      <div class="editor-container">
          <div class="control-group">
              <label for="dictation-correctionContent">Texto a Corregir y Procesar</label>
              <textarea id="dictation-correctionContent" rows="8"></textarea>
              <div class="button-toolbar">
                  <button id="dictation-correctButton" class="btn btn-primary ai-modal-btn"><i class="fas fa-wand-magic-sparkles"></i> Corregir con IA</button>
                  <button id="dictation-updateButton" class="btn ai-modal-btn"><i class="fas fa-sync"></i> Actualizar</button>
                  <button id="dictation-readAloudButton" class="btn ai-modal-btn"><i class="fas fa-volume-high"></i> Leer</button>
                  <button id="dictation-copyButton" class="btn ai-modal-btn"><i class="fas fa-copy"></i> Copiar</button>
                  <button id="dictation-cleanButton" class="btn ai-modal-btn"><i class="fas fa-broom"></i> Limpiar</button>
                  <button id="dictation-appendButton" class="btn ai-modal-btn"><i class="fas fa-plus"></i> Añadir al Editor</button>
              </div>
          </div>
          <div class="control-group">
              <label for="dictation-editContent">Editor de Nota</label>
              <textarea id="dictation-editContent" rows="15"></textarea>
               <div class="ia-settings">
                  <div class="selector-group">
                      <label for="dictation-providerSelector">Proveedor de IA</label>
                      <select id="dictation-providerSelector" class="browser-default"></select>
                  </div>
                  <div class="selector-group">
                      <label for="dictation-modelSelector">Modelo</label>
                      <select id="dictation-modelSelector" class="browser-default"></select>
                  </div>
                   <div class="selector-group" style="flex-basis: 100%; text-align: right; padding-top:10px;">
                    <button id="dictation-saveModelButton" class="btn ai-modal-btn"><i class="fas fa-save"></i> Guardar Modelo</button>
                  </div>
              </div>
          </div>
      </div>
  </div>

  <div id="improveModal">
      <div class="app-header">
          <h3><i class="fas fa-magic"></i> Mejorar Nota con IA</h3>
          <div class="main-controls">
              <button id="improve-saveButton" class="btn btn-primary ai-modal-btn"><i class="fas fa-save"></i> Guardar en Nota</button>
              <button id="improve-closeButton" class="btn btn-danger ai-modal-btn"><i class="fas fa-times"></i></button>
          </div>
      </div>
      <div class="editor-container">
          <div class="control-group">
              <label for="improve-originalContent">Texto Original</label>
              <textarea id="improve-originalContent" rows="10"></textarea>
          </div>
          <div class="control-group" style="text-align: center; padding: 10px 0; border-bottom: none;">
              <button id="improve-correctButton" class="btn btn-primary ai-modal-btn"><i class="fas fa-wand-magic-sparkles"></i> Mejorar con IA</button>
          </div>
          <div class="control-group">
              <label for="improve-correctedContent">Texto Mejorado</label>
              <textarea id="improve-correctedContent" rows="10"></textarea>
              <div class="button-toolbar">
                  <button id="improve-readAloudButton" class="btn ai-modal-btn"><i class="fas fa-volume-high"></i> Leer</button>
                  <button id="improve-copyButton" class="btn ai-modal-btn"><i class="fas fa-copy"></i> Copiar</button>
              </div>
          </div>
          <div class="control-group">
              <div class="ia-settings">
                  <div class="selector-group">
                      <label for="improve-providerSelector">Proveedor de IA</label>
                      <select id="improve-providerSelector" class="browser-default"></select>
                  </div>
                  <div class="selector-group">
                      <label for="improve-modelSelector">Modelo</label>
                      <select id="improve-modelSelector" class="browser-default"></select>
                  </div>
                  <div class="selector-group" style="flex-basis: 100%; text-align: right; padding-top:10px;">
                    <button id="improve-saveModelButton" class="btn ai-modal-btn"><i class="fas fa-save"></i> Guardar Modelo</button>
                  </div>
              </div>
          </div>
      </div>
  </div>

  <div id="llmSelectorOverlay" class="llm-selector-overlay">
    <div class="llm-selector-modal">
        <button id="llmSelectorClose" class="llm-selector-close">×</button>
        <h2>Seleccionar Modelo de IA</h2>
        <p>Elige un proveedor y modelo para usar en las funciones de IA.</p>
        <label for="llmProviderSelect" style="display: block; margin-bottom: 5px; font-weight: 500;">Proveedor</label>
        <select id="llmProviderSelect" class="browser-default"></select>
        <label for="llmModelSelect" style="display: block; margin-top: 15px; margin-bottom: 5px; font-weight: 500;">Modelo</label>
        <select id="llmModelSelect" class="browser-default"></select>
        <button id="llmSaveButton">Guardar Selección</button>
    </div>
  </div>

  <div id="image-resize-controls">
    <label for="image-size-slider">Tamaño:</label>
    <input type="range" id="image-size-slider" min="10" max="100" value="100">
  </div>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://unpkg.com/turndown/dist/turndown.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Evitar múltiples pestañas abiertas
      try {
        const channel = new BroadcastChannel('wdnotes_singleton_channel');
        channel.onmessage = (event) => {
          if (event.data === 'new_tab_opened') {
            alert('Se ha abierto una nueva pestaña de wdnotes. Esta pestaña se cerrará para evitar conflictos.');
            window.close();
          }
        };
        channel.postMessage('new_tab_opened');
        window.addEventListener('beforeunload', () => {
          channel.close();
        });
      } catch (e) {
        console.warn("La API BroadcastChannel no es compatible, la funcionalidad de pestaña única está desactivada.", e);
      }

      const urlParams = new URLSearchParams(window.location.search);
      const isSimpleMode = urlParams.get('modo') === 'simple';
      if (urlParams.get('theme') === 'dark') {
          document.body.classList.remove('light-theme'); // Dark is default now
      } else {
          document.body.classList.add('light-theme');
      }

      M.Sidenav.init(document.querySelectorAll('.sidenav'));
      M.Tooltip.init(document.querySelectorAll('.tooltipped'));
      M.Dropdown.init(document.querySelectorAll('.dropdown-trigger'), {constrainWidth: false, coverTrigger: false});

      async function loadConfig() {
          const defaultConfig = {
              TRASH_RETENTION_DAYS: 7,
              NOTES_PER_PAGE: 25,
              LLM_PROVIDERS_CONFIG: "/dav/apps/llm/config.txt",
              LLM_SELECTION_CONFIG: "/dav/apps/llm/llm-wdrss.txt",
              NOTE_BOOKS: [{ name: "Notas", path: "/dav/Notas/html/notas/" }]
          };
          try {
              const response = await fetch('wdnotes.conf');
              if (!response.ok) {
                  console.warn('wdnotes.conf no encontrado o ilegible. Usando configuración por defecto.');
                  M.toast({html: 'Archivo wdnotes.conf no encontrado. Usando valores por defecto.', classes: 'orange'});
                  return defaultConfig;
              }
              const text = await response.text();
              const config = { NOTE_BOOKS: [] };
              const lines = text.split('\n');

              for (const line of lines) {
                  const trimmedLine = line.trim();
                  if (trimmedLine === '' || trimmedLine.startsWith('#') || trimmedLine.startsWith('[')) {
                      continue;
                  }

                  const parts = trimmedLine.split('=');
                  const key = parts[0].trim();
                  const value = parts.slice(1).join('=').trim();

                  if (key === 'NOTE_BOOK') {
                      const match = value.match(/"([^"]+)"\s*,\s*"([^"]+)"/);
                      if (match && match.length === 3) {
                          config.NOTE_BOOKS.push({ name: match[1], path: match[2] });
                      }
                  } else if (key) {
                      config[key] = /^\d+$/.test(value) ? parseInt(value, 10) : value;
                  }
              }
              
              if (config.NOTE_BOOKS.length === 0) {
                config.NOTE_BOOKS = defaultConfig.NOTE_BOOKS;
              }
              
              return { ...defaultConfig, ...config };

          } catch (error) {
              console.error('Error al cargar wdnotes.conf:', error);
              M.toast({html: 'Error al cargar wdnotes.conf. Usando valores por defecto.', classes: 'red'});
              return defaultConfig;
          }
      }

      // Wrap main logic in an async function to wait for config
      (async () => {
        const APP_CONFIG = await loadConfig();
        const turndownService = new TurndownService();

        const booksContainer = document.getElementById('other-books-container');
        const predefinedPaths = APP_CONFIG.NOTE_BOOKS;
        if (booksContainer && predefinedPaths.length > 0) {
            let booksHtml = '<li class="divider" tabindex="-1"></li>';
            predefinedPaths.forEach(book => {
                booksHtml += `<li><a href="#!" data-path="${book.path}" style="text-transform: capitalize;">${book.name}</a></li>`;
            });
            booksContainer.innerHTML = booksHtml;
            
            booksContainer.addEventListener('click', e => {
                const target = e.target.closest('a[data-path]');
                if (target) {
                    e.preventDefault();
                    const path = target.dataset.path;
                    const url = new URL(window.location);
                    url.searchParams.set('dir', path);
                    window.location.href = url.toString();
                }
            });
        }

        const toggleThemeBtn = document.getElementById('toggle-theme-btn');
        if (toggleThemeBtn) {
            const updateThemeButtonText = () => {
                if (document.body.classList.contains('light-theme')) {
                    toggleThemeBtn.textContent = 'Tema Oscuro';
                } else {
                    toggleThemeBtn.textContent = 'Tema Claro';
                }
            };
            updateThemeButtonText();
            toggleThemeBtn.addEventListener('click', (e) => {
                e.preventDefault();
                const url = new URL(window.location);
                if (document.body.classList.contains('light-theme')) {
                    url.searchParams.set('theme', 'dark');
                } else {
                    url.searchParams.set('theme', 'light');
                }
                window.location.href = url.toString();
            });
        }

        const toggleModeBtn = document.getElementById('toggle-mode-btn');
        if (toggleModeBtn) {
            if (isSimpleMode) {
                toggleModeBtn.textContent = 'Modo Completo';
            } else {
                toggleModeBtn.textContent = 'Modo Simple';
            }
            toggleModeBtn.addEventListener('click', e => {
                e.preventDefault();
                const url = new URL(window.location);
                if (isSimpleMode) {
                    url.searchParams.delete('modo');
                } else {
                    url.searchParams.set('modo', 'simple');
                }
                window.location.href = url.toString();
            });
        }
      
        const universalNoteInput = document.getElementById('universal-note-input');
        const createNoteIconButton = document.getElementById('create-note-icon-btn');
        const refreshNotesIconButton = document.getElementById('refresh-notes-icon-btn');
        const clearFilterButton = document.getElementById('clear-filter-btn');
        const notesGridContainer = document.getElementById('notes-grid-container');
        const notesCountElement = document.getElementById('notes-count');
        const loadingIndicator = document.getElementById('loading-indicator');
        const trashInfoMessage = document.getElementById('trash-info-message');

        const modalEditorContainer = document.getElementById('modal-editor-container');
        const modalOverlay = document.getElementById('modal-overlay');
        const noteEditorContentEditable = document.getElementById('note-editor-contenteditable');
        const modalTitleInput = document.getElementById('modal-note-title-input');
        const closeEditorLink = document.getElementById('close-editor-link');
        const pinModalBtn = document.getElementById('pin-modal-btn');
        const addChecklistModalBtn = document.getElementById('add-checklist-modal-btn');
        const reorderChecklistBtn = document.getElementById('reorder-checklist-btn');
        const markdownToggleBtn = document.getElementById('markdown-toggle-btn');
        const noteEditorPreview = document.getElementById('note-editor-preview');
        const markdownViewControls = document.getElementById('markdown-view-controls');
        const mdViewPrevBtn = document.getElementById('md-view-prev-btn');
        const mdViewNextBtn = document.getElementById('md-view-next-btn');
        const archiveModalBtn = document.getElementById('archive-modal-btn');
        const manageTagsModalBtn = document.getElementById('manage-tags-modal-btn');
        const trashModalBtn = document.getElementById('trash-modal-btn');
        const modDateElement = document.getElementById('note-mod-date');
        const editTagsSidebarBtn = document.getElementById('edit-tags-sidebar-btn');
        const editTagsModal = document.getElementById('edit-tags-modal');
        const editTagsModalOverlay = document.getElementById('edit-tags-modal-overlay');
        const closeEditTagsModalBtn = document.getElementById('close-edit-tags-modal-btn');
        const allNotesBtn = document.getElementById('all-notes-btn');
        const archiveBtn = document.getElementById('archive-btn');
        const trashBtn = document.getElementById('trash-btn');
        const untaggedBtn = document.getElementById('untagged-notes-btn');
        const fullscreenModalBtn = document.getElementById('fullscreen-modal-btn');
        const duplicateNoteOption = document.getElementById('duplicate-note-option');
        const copyAsTextOption = document.getElementById('copy-as-text-option');
        const historyOption = document.getElementById('history-option');
        const dictationOption = document.getElementById('dictation-option');
        const improveNoteOption = document.getElementById('improve-note-option');
        const cleanFormatOption = document.getElementById('clean-format-option');
        const changeColorOption = document.getElementById('change-color-option');
        
        const historyModal = document.getElementById('history-modal');
        const historyModalOverlay = document.getElementById('history-modal-overlay');
        const historyContainer = document.getElementById('history-container');
        const closeHistoryModalBtn = document.getElementById('close-history-modal-btn');
        
        const globalHistoryBtn = document.getElementById('global-history-btn');
        const globalHistoryModal = document.getElementById('global-history-modal');
        const globalHistoryModalOverlay = document.getElementById('global-history-modal-overlay');
        const globalHistoryContainer = document.getElementById('global-history-container');
        const closeGlobalHistoryModalBtn = document.getElementById('close-global-history-modal-btn');

        const historyPreviewModal = document.getElementById('history-preview-modal');
        const historyPreviewModalOverlay = document.getElementById('history-preview-modal-overlay');
        const historyPreviewContent = document.getElementById('history-preview-content');
        const closeHistoryPreviewModalBtn = document.getElementById('close-history-preview-modal-btn');

        const multiSelectActionBar = document.getElementById('multi-select-action-bar');
        const selectionCount = document.getElementById('selection-count');
        const closeSelectionBtn = document.getElementById('close-selection-btn');

        const helpModal = document.getElementById('help-modal');
        const helpModalOverlay = document.getElementById('help-modal-overlay');
        const closeHelpModalBtn = document.getElementById('close-help-modal-btn');
        
        const createTableModal = document.getElementById('create-table-modal');
        const createTableModalOverlay = document.getElementById('create-table-modal-overlay');
        const addTableOption = document.getElementById('add-table-option');
        const confirmCreateTableBtn = document.getElementById('confirm-create-table-btn');
        const cancelCreateTableBtn = document.getElementById('cancel-create-table-btn');

        const encryptDecryptOption = document.getElementById('encrypt-decrypt-option');
        const editEncryptedOption = document.getElementById('edit-encrypted-option');
        const encryptModal = document.getElementById('encrypt-modal');
        const encryptModalOverlay = document.getElementById('encrypt-modal-overlay');
        const encryptModalTitle = document.getElementById('encrypt-modal-title');
        const encryptPasswordInput = document.getElementById('encrypt-password-input');
        const confirmEncryptBtn = document.getElementById('confirm-encrypt-btn');
        const cancelEncryptBtn = document.getElementById('cancel-encrypt-btn');
        const ENCRYPTION_PREFIX = 'AES_ENCRYPTED::';

        const toggleViewBtn = document.getElementById('toggle-view-btn');

        const addFileOption = document.getElementById('add-file-option');
        const fileAttachmentInput = document.getElementById('file-attachment-input');

        const addCameraOption = document.getElementById('add-camera-option');
        const cameraInput = document.getElementById('camera-input');

        const customColorPicker = document.getElementById('custom-color-picker');

        const progressOverlay = document.getElementById('progress-overlay');

        const excludePages = ['index.html', 'editor.html']; 
        const PIN_FILE_NAME = "pin.txt"; 
        const HIDDEN_TAG_SEPARATOR = '#';
        const TRASH_RETENTION_DAYS = APP_CONFIG.TRASH_RETENTION_DAYS;
        const PROVIDERS_CONFIG_DAV_PATH = APP_CONFIG.LLM_PROVIDERS_CONFIG;
        const LLM_SELECTION_URL = APP_CONFIG.LLM_SELECTION_CONFIG;
        const CSV_SEPARATOR = '⇄';
        const NOTES_PER_PAGE = APP_CONFIG.NOTES_PER_PAGE;
        let currentPage = 1;
        let currentViewNotes = {
            pinned: [],
            unpinned: []
        };
        
        let webdavNotesUrl = (APP_CONFIG.NOTE_BOOKS.length > 0) ? APP_CONFIG.NOTE_BOOKS[0].path : "/";
        const customDir = urlParams.get('dir');
        if (customDir) {
            let notesPath = customDir;
            if (!notesPath.endsWith('/')) { 
                notesPath += '/';
            }
            if (!notesPath.startsWith('/')) { 
                notesPath = '/' + notesPath;
            }
            webdavNotesUrl = notesPath;
        }
      
        let initialEditorState = { title: '', content: '' };
        let currentEditingNoteName = null;
        let saveInProgress = false;
        let currentPinnedNotesList = []; 
        let allUniqueTags = new Set();
        let allNotesDataMap = new Map();
        let displayNameMap = new Map();
        let activeColorPanel = null;
        let tagSuggestionPopup = null;
        let currentView = 'notes';
        
        let isSearchIndexReady = false;

        let selectedNotes = new Set();
        let longPressTimer = null;
        let isLongPress = false;
        let contentParser = new DOMParser();
        
        let currentDecryptionKey = null;
        let isEditingEncryptedNote = false;

        let globalHistoryAllVersions = [];
        let globalHistoryCurrentPage = 1;
        const globalHistoryVersionsPerPage = 20;

        let lastJumpedNoteIndex = -1;
        let markdownViewState = 1; // 0: Editor, 1: Split, 2: Preview

        const NOTE_COLORS = ['#ffffff', '#f28b82', '#fbbc04', '#fff475', '#ccff90', '#a7ffeb', '#cbf0f8', '#aecbfa', '#d7aefb', '#fdcfe8', '#e6c9a8', '#e8eaed'];
      
        function showProgress() {
            progressOverlay.classList.remove('hidden');
        }

        function hideProgress() {
            progressOverlay.classList.add('hidden');
        }

        function htmlToStructuredText(html) {
            if (!html) return '';
            const tempDiv = document.createElement('div');
            
            if (html.startsWith(ENCRYPTION_PREFIX)) {
                return "[Contenido Cifrado]";
            }

            let structuredHtml = html
                .replace(/<p>/gi, '\n<p>')
                .replace(/<div>/gi, '\n<div>')
                .replace(/<h[1-6]/gi, '\n\n<h')
                .replace(/<li/gi, '\n* <li');

            tempDiv.innerHTML = structuredHtml;

            return tempDiv.textContent.replace(/(\n\s*){3,}/g, '\n\n').trim();
        }

        function textToHtml(text) {
            if (!text) return '<p><br></p>';
            return text.trim().split('\n').map(p => `<p>${p.replace(/</g, '&lt;').replace(/>/g, '&gt;') || '<br>'}</p>`).join('');
        }

        function processWikilinks(html) {
          if (!html || html.startsWith(ENCRYPTION_PREFIX)) return html;
          const wikilinkRegex = /\[\[(.*?)\]\]/g;
          return html.replace(wikilinkRegex, (match, noteDisplayName) => {
              const trimmedDisplayName = noteDisplayName.trim();
              const targetNote = displayNameMap.get(trimmedDisplayName.toLowerCase());
              if (targetNote) {
                  return `<a href="?nota=${encodeURIComponent(targetNote.name)}" class="internal-link" data-note-name="${targetNote.name}">${trimmedDisplayName}</a>`;
              } else {
                  return `<a href="?crear=${encodeURIComponent(trimmedDisplayName)}" class="internal-link-broken" title="Nota no encontrada: '${trimmedDisplayName}'. Clic para crear.">${trimmedDisplayName}</a>`;
              }
          });
        }

        function unprocessWikilinks(html) {
            if (!html) return '';
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            tempDiv.querySelectorAll('a.internal-link, a.internal-link-broken').forEach(link => {
                link.replaceWith(`[[${link.textContent}]]`);
            });
            return tempDiv.innerHTML;
        }


        function linkifyContent(html) {
          if (!html) return '';
          if (html.startsWith(ENCRYPTION_PREFIX)) {
              return html;
          }
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = html;
          const urlRegex = /(\bhttps?:\/\/[^\s<>"']*[^\s<>"'.,!?)\]}])/g;
          const walker = document.createTreeWalker(tempDiv, NodeFilter.SHOW_TEXT);
          const nodesToReplace = [];

          while (walker.nextNode()) {
              const node = walker.currentNode;
              if (node.parentElement.tagName !== 'A' && node.parentElement.tagName !== 'SCRIPT' && node.parentElement.tagName !== 'STYLE' && urlRegex.test(node.nodeValue)) {
                  nodesToReplace.push(node);
              }
          }

          nodesToReplace.forEach(node => {
              const replacement = node.nodeValue.replace(urlRegex, '<a href="$&" target="_blank" rel="noopener noreferrer">$&</a>');
              const newContent = document.createRange().createContextualFragment(replacement);
              node.parentNode.replaceChild(newContent, node);
          });

          return tempDiv.innerHTML;
        }

        function isColorLight(hexColor) {
          if (!hexColor) return true;
          const color = (hexColor.charAt(0) === '#') ? hexColor.substring(1, 7) : hexColor;
          const r = parseInt(color.substring(0, 2), 16);
          const g = parseInt(color.substring(2, 4), 16);
          const b = parseInt(color.substring(4, 6), 16);
          const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
          return luminance > 0.6;
        }

        function applyColorToCard(noteCard, color) {
            const isDarkTheme = !document.body.classList.contains('light-theme');
            const defaultBgColor = isDarkTheme ? 'var(--bg-secondary)' : '#ffffff';
            
            const effectiveColor = color || defaultBgColor;
            noteCard.style.backgroundColor = effectiveColor;
            if (color && color !== '#ffffff') {
              noteCard.style.borderColor = color;
            } else {
              noteCard.style.borderColor = 'var(--border-color)';
            }

            if (color && color !== '#ffffff' && effectiveColor !== defaultBgColor) {
                if (isColorLight(color)) {
                    noteCard.classList.add('light-bg-card');
                } else {
                    noteCard.classList.remove('light-bg-card');
                }
            } else {
                noteCard.classList.remove('light-bg-card');
            }
        }

        function parseNoteFilename(baseNameRaw) {
            let displayName = baseNameRaw;
            let allTagsInFilename = [];

            const sepIndex = baseNameRaw.indexOf(HIDDEN_TAG_SEPARATOR);

            if (sepIndex !== -1) {
                displayName = baseNameRaw.substring(0, sepIndex);
                const tagsString = baseNameRaw.substring(sepIndex + 1);
                if (tagsString) {
                    allTagsInFilename = tagsString.split(HIDDEN_TAG_SEPARATOR).map(t => t.trim()).filter(t => t);
                }
            }
            
            if (!displayName) displayName = "Nota";

            let noteColor = null;
            let finalTags = [];
            let isArchived = false;
            let isTrashed = false;

            allTagsInFilename.forEach(tag => {
                if (tag.startsWith('c_')) {
                    noteColor = '#' + tag.substring(2);
                } else if (tag === 'archivada') {
                    isArchived = true;
                } else if (tag === 'papelera') {
                    isTrashed = true;
                } else {
                    finalTags.push(tag);
                }
            });

            finalTags.forEach(tag => allUniqueTags.add(tag.toLowerCase()));

            return {
                displayName: displayName,
                tags: finalTags,
                color: noteColor,
                isArchived: isArchived,
                isTrashed: isTrashed
            };
        }

        function closeSidebar() {
          var instance = M.Sidenav.getInstance(document.getElementById('sidebar-menu'));
          if (instance && instance.isOpen) instance.close();
        }
        
        async function fetchPinnedNotesFromServer() {
          try {
            const response = await fetch(webdavNotesUrl + PIN_FILE_NAME);
            if (response.ok) return (await response.text()).split('\n').map(name => name.trim()).filter(name => name); 
            if (response.status === 404) return []; 
            return []; 
          } catch (error) { return []; }
        }
        async function savePinnedNotesToServer(pinnedArray) {
          const content = pinnedArray.join('\n');
          showProgress();
          try {
            const response = await fetch(webdavNotesUrl + PIN_FILE_NAME, {
              method: 'PUT', headers: { 'Content-Type': 'text/plain; charset=UTF-8' }, body: content
            });
            if (!response.ok && response.status !== 201 && response.status !== 204) { 
              throw new Error(`Error al guardar fijados: ${response.status}`);
            }
            currentPinnedNotesList = [...pinnedArray];
          } catch (error) { 
              throw new Error('Error de red al guardar fijados.');
          } finally {
              hideProgress();
          }
        }
        function isNotePinned(noteName) { return currentPinnedNotesList.includes(noteName); }
        
        async function togglePinStatus(noteName) {
          const noteData = findNoteDataByDecodedName(noteName);
          if (!noteData) return;

          const originalPinnedStatus = noteData.isPinned;
          const originalPinnedList = [...currentPinnedNotesList];
          let newPinnedList;

          noteData.isPinned = !originalPinnedStatus;
          if (noteData.isPinned) {
              M.toast({html: `Nota fijada.`, classes: 'amber darken-1', displayLength: 1500});
              newPinnedList = [noteName, ...originalPinnedList.filter(n => n !== noteName)];
          } else {
              M.toast({html: `Fijación quitada.`, classes: 'grey lighten-1', displayLength: 1500});
              newPinnedList = originalPinnedList.filter(n => n !== noteName);
          }
          currentPinnedNotesList = newPinnedList; 
          displaySortedNotes(Array.from(allNotesDataMap.values()));

          try {
              await savePinnedNotesToServer(newPinnedList);
          } catch (error) {
              M.toast({html: `Error al fijar la nota: ${error.message}`, classes: 'red'});
              noteData.isPinned = originalPinnedStatus;
              currentPinnedNotesList = originalPinnedList; 
              displaySortedNotes(Array.from(allNotesDataMap.values()));
          }
        }
        
        async function showEditorView(noteName, options = {}) {
            currentEditingNoteName = noteName;
            
            const noteData = findNoteDataByDecodedName(noteName);
            if (!noteData) {
                M.toast({html: `No se pudo encontrar la nota.`, classes: 'red'});
                return;
            }

            // Immediately show the modal with basic info
            document.title = `wdnotes. ${noteData.displayName}`;
            const url = new URL(window.location);
            url.searchParams.set('nota', noteName);
            history.pushState({ note: noteName }, '', url);

            const titleWithTags = noteData.tags.length > 0
                ? `${noteData.displayName} ${noteData.tags.map(t => `#${t}`).join(' ')}`
                : noteData.displayName;
            modalTitleInput.value = titleWithTags;
            
            const date = noteData.date;
            const formattedDate = date.toLocaleDateString('es-ES', {day: '2-digit', month: '2-digit', year: 'numeric'});
            const formattedTime = date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
            modDateElement.innerHTML = `Edit: <span class="mod-date-date">${formattedDate}</span><span class="mod-date-time">${formattedTime}</span>`;
            
            const noteColor = noteData.color;
            if (noteColor && noteColor !== '#ffffff') {
                modalEditorContainer.style.backgroundColor = noteColor;
                if (isColorLight(noteColor)) {
                    modalEditorContainer.classList.remove('dark-bg');
                    modalEditorContainer.classList.add('light-bg');
                } else {
                    modalEditorContainer.classList.remove('light-bg');
                    modalEditorContainer.classList.add('dark-bg');
                }
            } else {
                modalEditorContainer.style.backgroundColor = '';
                modalEditorContainer.classList.remove('light-bg', 'dark-bg');
            }

            pinModalBtn.classList.toggle('pinned', noteData.isPinned);
            pinModalBtn.dataset.tooltip = noteData.isPinned ? "Quitar fijación" : "Fijar";

            const moveModalDropdown = document.getElementById('move-modal-dropdown');
            if (moveModalDropdown) {
                let moveOptions = '';
                predefinedPaths.forEach(p => {
                    if (p.path !== webdavNotesUrl) {
                        moveOptions += `<li><a href="#!" data-action="move-to" data-path="${p.path}">${p.name}</a></li>`;
                    }
                });
                moveModalDropdown.innerHTML = moveOptions;
                const moveTrigger = document.querySelector('a[data-target="move-modal-dropdown"]');
                if (moveTrigger) M.Dropdown.init(moveTrigger, {constrainWidth: false, coverTrigger: false, container: document.body, hover: false});
            }
            M.Tooltip.init(document.querySelectorAll('#modal-editor-container .tooltipped'));
            
            modalEditorContainer.classList.remove('hidden');
            modalOverlay.classList.remove('hidden');
            document.body.classList.add('modal-active');
            noteEditorContentEditable.innerHTML = '<p><i>Cargando...</i></p>';

            // Asynchronously fetch and display content
            const loadContent = async () => {
                if (!noteData.content) {
                    try {
                        const response = await fetch(noteData.path);
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        noteData.content = await response.text();
                    } catch(error) {
                        M.toast({html: `Error al cargar nota: ${error.message}`, classes: 'red'});
                        noteData.content = `<p>Error al cargar el contenido.</p>`;
                    }
                }
                
                const isEncrypted = noteData.content && noteData.content.startsWith(ENCRYPTION_PREFIX);
                document.querySelectorAll('#more-options-dropdown li').forEach(li => li.style.display = 'block');
                
                if (isEncrypted) {
                    noteEditorContentEditable.innerHTML = `<div style="text-align: center; padding: 40px; color: var(--text-muted);"><i class="material-icons" style="font-size: 3em; display: block;">lock</i><h3>Nota Cifrada</h3><p>Usa la opción "Editar Cifrado" en el menú para ver y editar.</p></div>`;
                    noteEditorContentEditable.contentEditable = "false";
                    document.querySelectorAll('#more-options-dropdown li').forEach(li => {
                        if (li.id !== 'edit-encrypted-option-li' && li.id !== 'duplicate-note-option-li') {
                            li.style.display = 'none';
                        }
                    });
                    editEncryptedOption.parentElement.style.display = 'block';
                } else {
                    noteEditorContentEditable.innerHTML = processWikilinks(linkifyContent(noteData.content));
                    noteEditorContentEditable.contentEditable = "true";
                    editEncryptedOption.parentElement.style.display = 'none';
                    // Defer link calculation to run in the background
                    renderLinks(noteData); 
                }

                addCopyButtonsToCodeBlocks(noteEditorContentEditable);
                initialEditorState = { title: titleWithTags, content: noteData.content };
                
                if (options.isNew) {
                    setTimeout(() => {
                        noteEditorContentEditable.focus();
                        const pTag = noteEditorContentEditable.querySelector('p');
                        if (pTag) {
                            const range = document.createRange();
                            const sel = window.getSelection();
                            range.setStart(pTag, 0);
                            range.collapse(true);
                            sel.removeAllRanges();
                            sel.addRange(range);
                        }
                    }, 100);
                } else if (!isEncrypted) {
                   setTimeout(() => noteEditorContentEditable.focus(), 100);
                }
            };
            
            loadContent();
        }

        async function renderLinks(noteData) {
            const backlinks = [];
            const forwardLinks = [];
            const wikilinkRegex = /\[\[(.*?)\]\]/g;
            const searchStringForBacklinks = `[[${noteData.displayName}]]`;
            
            let match;
            while ((match = wikilinkRegex.exec(noteData.content)) !== null) {
                const linkedNoteName = match[1];
                const linkedNote = displayNameMap.get(linkedNoteName.toLowerCase());
                if (linkedNote) {
                    forwardLinks.push(linkedNote);
                }
            }

            for (const otherNote of allNotesDataMap.values()) {
                if (otherNote.name === noteData.name) continue;

                let contentToCheck = otherNote.content;
                if (!contentToCheck) {
                    try {
                        const res = await fetch(otherNote.path);
                        if (res.ok) {
                           contentToCheck = await res.text();
                           otherNote.content = contentToCheck;
                        }
                    } catch(e) { contentToCheck = ""; }
                }
                
                if (contentToCheck && contentToCheck.includes(searchStringForBacklinks)) {
                    backlinks.push(otherNote);
                }
            }

            const editor = document.getElementById('note-editor-contenteditable');
            if (currentEditingNoteName !== noteData.name || !editor) return; // User has moved on

            if (backlinks.length > 0 || forwardLinks.length > 0) {
                const linksContainer = document.createElement('div');
                linksContainer.className = 'links-container';
                let linksHtml = '';

                if (forwardLinks.length > 0) {
                    linksHtml += '<h4>Vinculado a:</h4><ul>';
                    forwardLinks.forEach(b => {
                        linksHtml += `<li><a href="?nota=${encodeURIComponent(b.name)}" class="internal-link" data-note-name="${b.name}">${b.displayName}</a></li>`;
                    });
                    linksHtml += '</ul>';
                }

                if (backlinks.length > 0) {
                    linksHtml += '<h4>Vinculado desde:</h4><ul>';
                    backlinks.forEach(b => {
                        linksHtml += `<li><a href="?nota=${encodeURIComponent(b.name)}" class="internal-link" data-note-name="${b.name}">${b.displayName}</a></li>`;
                    });
                    linksHtml += '</ul>';
                }

                linksContainer.innerHTML = linksHtml;
                editor.appendChild(linksContainer);
            }
        }
         
        async function hideEditorView() {
            closeTagSuggestionPopup(false);
            document.title = 'wdnotes';
            let currentContent;
            const isMarkdown = modalEditorContainer.classList.contains('markdown-active');
            
            if (isMarkdown) {
                currentContent = noteEditorPreview.innerHTML;
            } else {
                currentContent = noteEditorContentEditable.innerHTML;
            }

            const currentTitle = modalTitleInput.value.trim();

            // Remove the links container before saving
            const linksContainer = noteEditorContentEditable.querySelector('.links-container');
            if (linksContainer) {
                linksContainer.remove();
                currentContent = isMarkdown ? noteEditorPreview.innerHTML : noteEditorContentEditable.innerHTML;
            }

            currentContent = unprocessWikilinks(currentContent);

            if (isEditingEncryptedNote && currentDecryptionKey) {
                const encrypted = CryptoJS.AES.encrypt(currentContent, currentDecryptionKey).toString();
                currentContent = ENCRYPTION_PREFIX + encrypted;
            }
            
            const titleChanged = currentTitle !== initialEditorState.title;
            const contentChanged = currentContent !== initialEditorState.content;

            let needsSave = titleChanged || contentChanged;
            let needsRefresh = false;

            if(initialEditorState.content.startsWith(ENCRYPTION_PREFIX) && !isEditingEncryptedNote) {
                needsSave = false;
            }

            if (needsSave) {
                await saveNoteFromEditor(currentContent);
                needsRefresh = true;
            }
            
            isEditingEncryptedNote = false;
            currentDecryptionKey = null;
            editEncryptedOption.parentElement.style.display = 'none';
            encryptDecryptOption.parentElement.style.display = 'block';
            noteEditorContentEditable.contentEditable = "true";
            modalEditorContainer.classList.remove('markdown-active', 'md-editor-only', 'md-preview-only');
            noteEditorPreview.classList.add('hidden');
            markdownViewControls.classList.add('hidden');
            noteEditorContentEditable.style.display = 'block';

            const url = new URL(window.location);
            url.searchParams.delete('nota');
            history.replaceState({}, '', url);

            modalEditorContainer.classList.add('hidden');
            modalOverlay.classList.add('hidden');
            document.body.classList.remove('modal-active');
            noteEditorContentEditable.innerHTML = '';
            modalTitleInput.value = '';
            currentEditingNoteName = null;
            
            modalEditorContainer.style.backgroundColor = '';
            modalEditorContainer.classList.remove('light-bg', 'dark-bg');
            modalEditorContainer.classList.remove('fullscreen-mode');
            
            if (needsRefresh) {
                fetchNotesAndDisplayCards();
            }
        }

        function findNoteDataByDecodedName(decodedName) {
            for (const value of allNotesDataMap.values()) {
                if (value.name === decodedName) {
                    return value;
                }
            }
            return null;
        }
         
        function sanitizeForFilenamePart(namePart, isTag = false) {
            if (!namePart) return '';
            let sanitized = namePart.trim();
            if (isTag) {
              sanitized = sanitized.replace(/\s+/g, '_');
              sanitized = sanitized.replace(new RegExp(HIDDEN_TAG_SEPARATOR, 'g'), '');
            }
            sanitized = sanitized.replace(/[<>:"/\\|?*%\0\x00-\x1F\x7F]/g, ''); 
            if (isTag) sanitized = sanitized.replace(/_+/g, '_');
            
            sanitized = sanitized.replace(/^\.+|\.+$/g, '').trim();
            return sanitized;
        }

        function buildBaseFilename(displayName, tags, color, isArchived, isTrashed) {
            let base = sanitizeForFilenamePart(displayName, false);
            let allTags = tags ? [...new Set(tags)] : [];

            if (color && color !== '#ffffff') {
                const colorTag = 'c_' + color.substring(1);
                allTags = allTags.filter(t => !t.startsWith('c_'));
                allTags.push(colorTag);
            }
            
            allTags = allTags.filter(t => t !== 'archivada' && t !== 'papelera');
            if (isArchived) allTags.push('archivada');
            if (isTrashed) allTags.push('papelera');

            if (allTags.length > 0) {
                base += HIDDEN_TAG_SEPARATOR + allTags.map(t => sanitizeForFilenamePart(t, true)).join(HIDDEN_TAG_SEPARATOR);
            }
            return base || "nueva_nota";
        }

        function parseUserInputForFilename(userInput) {
          userInput = userInput.trim();
          let displayName = userInput;
          let tags = [];

          const matches = userInput.match(/\B#([a-zA-Z0-9\-_]+)/g) || [];
          if (matches.length > 0) {
              matches.forEach(match => {
                  displayName = displayName.replace(match, '').trim();
                  tags.push(sanitizeForFilenamePart(match.substring(1), true));
              });
          }
          
          displayName = sanitizeForFilenamePart(displayName, false);
          if (!displayName) {
              displayName = (tags.length > 0) ? "Nota" : "Nueva Nota";
          }
          
          const baseFileName = buildBaseFilename(displayName, tags, null, false, false);
          return { baseFileName, displayTitle: displayName, tags: tags };
        }
        
        function _parseWebDavEntry(responseElement, currentHtmlFileName) {
            let href = responseElement.getElementsByTagName("D:href")[0].textContent;
            if (!href.endsWith(".html")) return null;

            const fullPath = href;
            const fileNameWithExtension = fullPath.substring(fullPath.lastIndexOf("/") + 1);
            const decodedFileName = decodeURIComponent(fileNameWithExtension);

            if (excludePages.includes(decodedFileName) || decodedFileName === currentHtmlFileName) return null;

            const baseNameRaw = decodedFileName.replace(".html", "");
            const { displayName, tags, color, isArchived, isTrashed } = parseNoteFilename(baseNameRaw);

            return {
                name: baseNameRaw,
                fullName: fileNameWithExtension,
                path: fullPath,
                date: new Date(responseElement.getElementsByTagName("D:getlastmodified")[0].textContent),
                isPinned: isNotePinned(baseNameRaw),
                displayName: displayName,
                tags: tags,
                color: color,
                isArchived: isArchived,
                isTrashed: isTrashed,
                content: null, 
                textContentForSearch: '' 
            };
        }
        
        async function fetchNotesAndDisplayCards() {
          const startTime = performance.now();
          
          showProgress();
          notesCountElement.textContent = '';
          const currentHtmlFileName = new URL(document.baseURI).pathname.split('/').pop();

          try {
              currentPinnedNotesList = await fetchPinnedNotesFromServer();
              
              allNotesDataMap.clear();
              displayNameMap.clear();
              allUniqueTags.clear();
              isSearchIndexReady = false; 

              const response = await fetch(webdavNotesUrl, {
                  method: 'PROPFIND',
                  headers: { 'Content-Type': 'text/xml', 'Depth': '1' }
              });

              if (response.status !== 207) throw new Error(`Error lista: ${response.status}`);

              const responseText = await response.text();
              const xml = new DOMParser().parseFromString(responseText, "text/xml");
              const responses = xml.getElementsByTagName("D:response");
              let tempAllFiles = [];

              for (let r of responses) {
                  const fileDataObject = _parseWebDavEntry(r, currentHtmlFileName);
                  if (fileDataObject) {
                      fileDataObject.textContentForSearch = (fileDataObject.displayName + " " + fileDataObject.tags.join(" ")).toLowerCase();
                      tempAllFiles.push(fileDataObject);
                  }
              }

              const notesToDelete = tempAllFiles.filter(note => {
                  if (!note.isTrashed) return false;
                  const ageInDays = (new Date() - note.date) / (1000 * 60 * 60 * 24);
                  return ageInDays > TRASH_RETENTION_DAYS;
              });

              if (notesToDelete.length > 0) {
                  const deletionPromises = notesToDelete.map(note => permanentlyDeleteNote(note.fullName, note.name, false)); 
                  await Promise.all(deletionPromises);
                  M.toast({html: `${notesToDelete.length} nota(s) antigua(s) eliminada(s) de la papelera.`});
                  
                  const deletedFullNames = new Set(notesToDelete.map(n => n.fullName));
                  tempAllFiles = tempAllFiles.filter(note => !deletedFullNames.has(note.fullName));
              }
              
              tempAllFiles.forEach(note => {
                allNotesDataMap.set(note.fullName, note);
                displayNameMap.set(note.displayName.toLowerCase(), note);
              });

              displayTagsInSidebar(Array.from(allUniqueTags).sort());
              displaySortedNotes(tempAllFiles);
              updateSidebarCounts();

              const endTime = performance.now();
              const elapsedTime = ((endTime - startTime) / 1000).toFixed(1);
              console.log(`Initial load time: ${elapsedTime} seconds`);

          } catch (error) {
              M.toast({html: `${error.message || 'Error de red'}`, classes: 'red'});
          } finally {
              hideProgress();
          }
        }

        function addCopyButtonsToCodeBlocks(container) {
            const codeBlocks = container.querySelectorAll('pre');
            codeBlocks.forEach(pre => {
                if (pre.querySelector('.copy-code-btn')) return;
                
                const button = document.createElement('button');
                button.className = 'copy-code-btn';
                button.innerHTML = '<i class="material-icons" style="font-size: 16px;">content_copy</i>';
                button.title = 'Copiar código';

                button.addEventListener('click', (event) => {
                    event.stopPropagation();

                    const preClone = pre.cloneNode(true);
                    if (preClone.querySelector('.copy-code-btn')) {
                      preClone.querySelector('.copy-code-btn').remove();
                    }
                    
                    const codeToCopy = preClone.innerText;

                    navigator.clipboard.writeText(codeToCopy).then(() => {
                        button.innerHTML = '<i class="material-icons" style="font-size: 16px;">check</i>';
                        M.toast({html: 'Código copiado al portapapeles', classes: 'green'});
                        setTimeout(() => {
                            button.innerHTML = '<i class="material-icons" style="font-size: 16px;">content_copy</i>';
                        }, 2000);
                    }).catch(err => {
                        console.error('Error al copiar el código: ', err);
                        M.toast({html: 'No se pudo copiar el código', classes: 'red'});
                    });
                });

                pre.appendChild(button);
            });
        }

        function renderPagination() {
            const paginationContainer = document.getElementById('pagination-container');
            paginationContainer.innerHTML = '';
            const totalUnpinned = currentViewNotes.unpinned.length;
            const totalPages = Math.ceil(totalUnpinned / NOTES_PER_PAGE);

            if (totalPages <= 1) {
                paginationContainer.style.display = 'none';
                return;
            }
            paginationContainer.style.display = 'block';

            const ul = document.createElement('ul');
            ul.className = 'pagination';

            const prevLi = document.createElement('li');
            prevLi.className = (currentPage === 1) ? 'disabled' : 'waves-effect';
            prevLi.innerHTML = `<a href="#!"><i class="material-icons">chevron_left</i></a>`;
            prevLi.addEventListener('click', (e) => {
                e.preventDefault();
                if (currentPage > 1) {
                    currentPage--;
                    renderNotesPage();
                }
            });
            ul.appendChild(prevLi);

            const pageInfoLi = document.createElement('li');
            pageInfoLi.className = 'page-info';
            pageInfoLi.textContent = `Página ${currentPage} de ${totalPages}`;
            ul.appendChild(pageInfoLi);

            const nextLi = document.createElement('li');
            nextLi.className = (currentPage === totalPages) ? 'disabled' : 'waves-effect';
            nextLi.innerHTML = `<a href="#!"><i class="material-icons">chevron_right</i></a>`;
            nextLi.addEventListener('click', (e) => {
                e.preventDefault();
                if (currentPage < totalPages) {
                    currentPage++;
                    renderNotesPage();
                }
            });
            ul.appendChild(nextLi);

            paginationContainer.appendChild(ul);
        }

        function renderNotesPage() {
            notesGridContainer.innerHTML = '';
            trashInfoMessage.classList.add('hidden');
            if (currentView === 'trash') {
                trashInfoMessage.textContent = `Las notas de la papelera se eliminan después de ${TRASH_RETENTION_DAYS} días.`;
                trashInfoMessage.classList.remove('hidden');
            }

            const fragment = document.createDocumentFragment();

            const pinnedToDisplay = currentViewNotes.pinned;
            
            const startIndex = (currentPage - 1) * NOTES_PER_PAGE;
            const endIndex = startIndex + NOTES_PER_PAGE;
            const unpinnedToDisplay = currentViewNotes.unpinned.slice(startIndex, endIndex);

            const totalToDisplay = pinnedToDisplay.length + currentViewNotes.unpinned.length;

            if (totalToDisplay === 0) {
                const p = document.createElement('p');
                p.style.textAlign = 'center'; p.style.color = 'var(--text-muted)';
                p.textContent = 'No hay notas...';
                fragment.appendChild(p);
            } else {
                if (pinnedToDisplay.length > 0 && !notesGridContainer.classList.contains('list-view')) {
                    const title = document.createElement('h5');
                    title.className = 'grid-section-title';
                    title.textContent = 'Fijadas';
                    fragment.appendChild(title);
                    pinnedToDisplay.forEach(fileData => fragment.appendChild(createNoteCardElement(fileData)));
                } else if (pinnedToDisplay.length > 0) {
                    pinnedToDisplay.forEach(fileData => fragment.appendChild(createNoteCardElement(fileData)));
                }

                if (unpinnedToDisplay.length > 0) {
                    if (pinnedToDisplay.length > 0 && !notesGridContainer.classList.contains('list-view')) {
                        const title = document.createElement('h5');
                        title.className = 'grid-section-title';
                        title.textContent = 'Otras';
                        fragment.appendChild(title);
                    }
                    unpinnedToDisplay.forEach(fileData => fragment.appendChild(createNoteCardElement(fileData)));
                }
            }

            notesGridContainer.appendChild(fragment);
            addCopyButtonsToCodeBlocks(notesGridContainer);
            notesCountElement.textContent = `${totalToDisplay} nota(s) encontradas.`;
            
            M.Dropdown.init(notesGridContainer.querySelectorAll('.dropdown-trigger'), {constrainWidth: false, coverTrigger: false, container: document.body});
            M.Tooltip.init(notesGridContainer.querySelectorAll('.tooltipped'));
            
            renderPagination();

            if (window.innerWidth >= 768) {
                const currentlyFocused = notesGridContainer.querySelector('.keyboard-focused');
                if(currentlyFocused) currentlyFocused.classList.remove('keyboard-focused');
                
                const firstVisibleNote = notesGridContainer.querySelector('.note-card:not([style*="display: none"])');
                if (firstVisibleNote) {
                    firstVisibleNote.classList.add('keyboard-focused');
                }
            }
        }

        function displaySortedNotes(filesArray) {
            lastJumpedNoteIndex = -1;
            let filteredFiles;
            switch (currentView) {
                case 'archive':
                    filteredFiles = filesArray.filter(f => f.isArchived && !f.isTrashed);
                    break;
                case 'trash':
                    filteredFiles = filesArray.filter(f => f.isTrashed);
                    break;
                case 'untagged':
                    filteredFiles = filesArray.filter(f => !f.isArchived && !f.isTrashed && f.tags.length === 0);
                    break;
                default: // 'notes'
                    filteredFiles = filesArray.filter(f => !f.isArchived && !f.isTrashed);
            }

            const pinnedFiles = filteredFiles.filter(f => f.isPinned).sort((a, b) => currentPinnedNotesList.indexOf(a.name) - currentPinnedNotesList.indexOf(b.name));
            const unpinnedFiles = filteredFiles.filter(f => !f.isPinned).sort((a, b) => b.date - a.date);
            
            currentViewNotes.pinned = pinnedFiles;
            currentViewNotes.unpinned = unpinnedFiles;
            
            currentPage = 1;

            renderNotesPage();
        }
        
        function createNoteCardElement(fileData) {
          const isListView = notesGridContainer.classList.contains('list-view');

          if (isListView) {
              const item = document.createElement('div');
              item.className = 'note-card';
              if (fileData.isPinned) item.classList.add('pinned-note');
              item.dataset.fileName = fileData.name;
              item.dataset.fullName = fileData.fullName;
              
              const formattedDate = fileData.date.toLocaleString('es-ES', {
                  year: 'numeric', month: 'numeric', day: 'numeric',
                  hour: '2-digit', minute: '2-digit', second: '2-digit'
              });

              item.innerHTML = `
                  <span class="list-view-bullet">•</span>
                  <span class="list-view-title">${fileData.displayName}</span>
                  <span class="list-view-separator">-</span>
                  <span class="list-view-date">${formattedDate}</span>
              `;
              return item;
          }

          const noteCard = document.createElement('div');
          noteCard.className = 'note-card';
          if (fileData.isPinned) noteCard.classList.add('pinned-note');
          if (selectedNotes.has(fileData.name)) noteCard.classList.add('selected');
          noteCard.dataset.fileName = fileData.name; 
          noteCard.dataset.fullName = fileData.fullName;
          
          const pinTooltip = fileData.isPinned ? "Quitar fijación" : "Fijar";

          noteCard.innerHTML = `
              <div class="selection-overlay"><i class="material-icons">check</i></div>
              <button title="${pinTooltip}" class="pin-toggle-btn tooltipped" data-position="bottom" data-tooltip="${pinTooltip}" data-action="pin"><i class="material-icons">push_pin</i></button>
              <i class="material-icons pin-indicator">push_pin</i>
          `;

          const headerDiv = document.createElement('div');
          headerDiv.className = 'note-card-header';
          const titleDisplay = document.createElement('div');
          titleDisplay.className = 'note-card-title-display';
          titleDisplay.textContent = fileData.displayName;
          headerDiv.appendChild(titleDisplay);
          noteCard.appendChild(headerDiv);

          applyColorToCard(noteCard, fileData.color);

          const contentDiv = document.createElement('div');
          contentDiv.className = 'note-card-content';
          if (fileData.content) {
              if (fileData.content.startsWith(ENCRYPTION_PREFIX)) {
                  contentDiv.innerHTML = `<i class="material-icons" style="font-size: 1.2em; vertical-align: bottom; margin-right: 4px;">lock</i> <em>Nota Cifrada</em>`;
              } else {
                  contentDiv.innerHTML = processWikilinks(linkifyContent(fileData.content));
              }
          }
          noteCard.appendChild(contentDiv);
          
          if (fileData.tags && fileData.tags.length > 0) {
              const pillsContainer = document.createElement('div');
              pillsContainer.className = 'note-card-pills';
              fileData.tags.forEach(tag => {
                  const pill = document.createElement('span');
                  pill.className = 'tag-pill';
                  pill.textContent = tag;
                  pillsContainer.appendChild(pill);
              });
              noteCard.appendChild(pillsContainer);
          }
          
          const actionsDiv = document.createElement('div');
          actionsDiv.className = 'note-actions';
          
          if (fileData.isTrashed) {
              actionsDiv.innerHTML = `
                  <button title="Restaurar" class="restore-btn tooltipped" data-position="bottom" data-tooltip="Restaurar" data-action="restore"><i class="material-icons">restore_from_trash</i></button>
                  <button title="Borrar permanentemente" class="delete-btn tooltipped" data-position="bottom" data-tooltip="Borrar permanentemente" data-action="delete-permanent"><i class="material-icons">delete_forever</i></button>
              `;
          } else {
              const archiveIcon = fileData.isArchived ? 'unarchive' : 'archive';
              const archiveTooltip = fileData.isArchived ? 'Desarchivar' : 'Archivar';
              const archiveAction = fileData.isArchived ? 'unarchive' : 'archive';
              
              let reorderButtons = '';
              if(fileData.isPinned) {
                  reorderButtons = `
                      <button title="Mover arriba" class="tooltipped" data-position="bottom" data-tooltip="Mover arriba" data-action="reorder-up"><i class="material-icons">arrow_upward</i></button>
                      <button title="Mover abajo" class="tooltipped" data-position="bottom" data-tooltip="Mover abajo" data-action="reorder-down"><i class="material-icons">arrow_downward</i></button>
                  `;
              }

              let moveButtonAndDropdown = '';
              let moveOptions = '';
              predefinedPaths.forEach(p => {
                  if (p.path !== webdavNotesUrl) {
                      moveOptions += `<li><a href="#!" data-action="move-to" data-path="${p.path}" data-note-full-name="${fileData.fullName}">${p.name}</a></li>`;
                  }
              });

              if (moveOptions) {
                  const uniqueDropdownId = `move-dropdown-${fileData.name.replace(/[^a-zA-Z0-9]/g, '')}`;
                  moveButtonAndDropdown = `<button class="dropdown-trigger tooltipped" data-position="bottom" data-tooltip="Mover" data-target="${uniqueDropdownId}"><i class="material-icons">drive_file_move</i></button>`;
              }

              actionsDiv.innerHTML = `
                  ${reorderButtons}
                  <button title="Copiar contenido" class="copy-btn tooltipped" data-position="bottom" data-tooltip="Copiar contenido" data-action="copy"><i class="material-icons">content_copy</i></button>
                  <button title="Limpiar formato" class="clean-format-btn tooltipped" data-position="bottom" data-tooltip="Limpiar formato" data-action="clean-format"><i class="material-icons">format_clear</i></button>
                  ${moveButtonAndDropdown}
                  <button title="${archiveTooltip}" class="archive-btn tooltipped" data-position="bottom" data-tooltip="${archiveTooltip}" data-action="${archiveAction}"><i class="material-icons">${archiveIcon}</i></button>
                  <button title="Etiquetas" class="manage-tags-btn tooltipped" data-position="bottom" data-tooltip="Etiquetas" data-action="manage-tags"><i class="material-icons">local_offer</i></button>
                  <button title="Cambiar color" class="change-color-btn tooltipped" data-position="bottom" data-tooltip="Color" data-action="change-color"><i class="material-icons">palette</i></button>
                  <button title="Mover a papelera" class="delete-btn tooltipped" data-position="bottom" data-tooltip="Mover a papelera" data-action="trash"><i class="material-icons">delete_outline</i></button>
              `;
              noteCard.appendChild(actionsDiv);
              
              if (moveOptions) {
                  const uniqueDropdownId = `move-dropdown-${fileData.name.replace(/[^a-zA-Z0-9]/g, '')}`;
                  const moveDropdown = document.createElement('ul');
                  moveDropdown.id = uniqueDropdownId;
                  moveDropdown.className = 'dropdown-content';
                  moveDropdown.innerHTML = moveOptions;
                  noteCard.appendChild(moveDropdown);
              }
          }
          
          return noteCard;
        }
        
      function getNoteColors() {
          const customColors = JSON.parse(localStorage.getItem('wdnotes-custom-colors') || '[]');
          return [...NOTE_COLORS, ...customColors];
      }
        
      function saveCustomColor(color) {
          let customColors = JSON.parse(localStorage.getItem('wdnotes-custom-colors') || '[]');
          if (!customColors.includes(color)) {
              customColors.push(color);
              localStorage.setItem('wdnotes-custom-colors', JSON.stringify(customColors));
          }
      }
        
        function toggleColorPalettePanel(parentElement, fileData, buttonElement) {
          if (activeColorPanel) { activeColorPanel.remove(); activeColorPanel = null; }
          
          const isModal = parentElement.id === 'modal-editor-container';
          const isMultiSelect = selectedNotes.size > 0 && !isModal;
          
          const panel = document.createElement('div');
          panel.className = 'color-palette-panel';
          
          const allColors = getNoteColors();

          allColors.forEach(color => {
              const swatch = document.createElement('div');
              swatch.className = 'color-swatch';
              swatch.style.backgroundColor = color;
              swatch.dataset.color = color;
              const currentColor = isMultiSelect ? null : (fileData.color || '#ffffff');
              if (color === currentColor) {
                  swatch.innerHTML = `<i class="material-icons" style="font-size: 18px;">check</i>`;
                  swatch.classList.add('active');
                  if (!isColorLight(color)) swatch.classList.add('dark-swatch');
              }
              panel.appendChild(swatch);
          });
          
          const addSwatch = document.createElement('div');
          addSwatch.className = 'color-swatch';
          addSwatch.innerHTML = `<i class="material-icons">add</i>`;
          addSwatch.title = "Añadir color personalizado";
          addSwatch.addEventListener('click', () => {
              customColorPicker.click();
          });
          panel.appendChild(addSwatch);

          const applyColor = async (newColor) => {
              panel.remove(); activeColorPanel = null;
              
              if (isMultiSelect) {
                  await handleMultiColorChange(newColor);
                  return;
              }

              const noteToUpdate = findNoteDataByDecodedName(currentEditingNoteName || fileData.name);
              if (!noteToUpdate) return;
              
              const newBaseName = buildBaseFilename(noteToUpdate.displayName, noteToUpdate.tags, newColor, noteToUpdate.isArchived, noteToUpdate.isTrashed);
              if (newBaseName === noteToUpdate.name) return;

              const renamed = await renameNote(noteToUpdate, newBaseName);
              if (renamed) {
                  if (isModal) {
                      currentEditingNoteName = renamed.name;
                      allNotesDataMap.set(renamed.fullName, renamed);
                      showEditorView(renamed.name);
                  } else {
                     noteToUpdate.color = newColor; 
                     noteToUpdate.name = renamed.name;
                     noteToUpdate.fullName = renamed.fullName;
                     noteToUpdate.path = renamed.path;
                     applyColorToCard(parentElement, newColor);
                     allNotesDataMap.delete(fileData.fullName);
                     allNotesDataMap.set(renamed.fullName, noteToUpdate);
                  }
              }
          };

          customColorPicker.onchange = (e) => {
              const newColor = e.target.value;
              saveCustomColor(newColor);
              applyColor(newColor);
          };

          panel.addEventListener('click', (e) => {
              const swatch = e.target.closest('.color-swatch[data-color]');
              if (swatch) {
                  applyColor(swatch.dataset.color);
              }
          });

          if (isMultiSelect) {
              document.body.appendChild(panel);
              const btnRect = buttonElement.getBoundingClientRect();
              panel.style.position = 'fixed';
              panel.style.top = `${btnRect.bottom + 8}px`;
              panel.style.left = `${btnRect.left}px`;
          } else {
              parentElement.appendChild(panel);
              if(isModal) panel.style.bottom = '50px';
          }

          activeColorPanel = panel;

          setTimeout(() => {
              document.addEventListener('click', function closePanelOnClickOutside(event) {
                  if (activeColorPanel && !activeColorPanel.contains(event.target) && !buttonElement.contains(event.target)) {
                      activeColorPanel.remove(); activeColorPanel = null;
                      document.removeEventListener('click', closePanelOnClickOutside);
                  }
              }, { once: true, capture: true });
          }, 0);
        }
        
        async function addNewNote(noteTitle) {
          let userInput = noteTitle || universalNoteInput.value.trim();
          if (!userInput) { 
              M.toast({html: 'Escribe un título para la nueva nota.', classes: 'orange'}); 
              universalNoteInput.focus(); 
              return; 
          }
          
          const { baseFileName, displayTitle } = parseUserInputForFilename(userInput);
          const newNotePath = webdavNotesUrl + encodeURIComponent(baseFileName) + `.html`;
          
          showProgress();
          try {
              const headResponse = await fetch(newNotePath, { method: 'HEAD' });
              if (headResponse.ok) { 
                  M.toast({html: `Una nota con el título "${displayTitle}" ya existe.`, classes: 'red'}); 
                  return; 
              }
          } catch(e) { }
          
          const initialContent = `<!DOCTYPE html><html lang="es"><head><meta charset="UTF-8"><title>${displayTitle}</title></head><body><h1>${displayTitle}</h1><p><br></p></body></html>`;
          
          try {
              const response = await fetch(newNotePath, {
                  method: 'PUT',
                  headers: { 'Content-Type': 'text/html; charset=UTF-8' },
                  body: initialContent
              });

              if (response.ok || response.status === 201 || response.status === 204) {
                  M.toast({html: `Nota "${displayTitle}" creada.`, classes: 'green'});
                  if(!noteTitle) universalNoteInput.value = '';
                  await fetchNotesAndDisplayCards(); 
                  showEditorView(baseFileName, { isNew: true });
              } else {
                  throw new Error(`Error al crear: ${response.status}`);
              }
          } catch (error) {
              M.toast({html: `${error.message || 'Error de red al crear.'}`, classes: 'red'});
          } finally {
              hideProgress();
          }
        }

        async function permanentlyDeleteNote(noteFullName, baseName, showToast = true) {
          const notePath = webdavNotesUrl + noteFullName;
          let newPinnedList = [...currentPinnedNotesList];
          const wasPinned = newPinnedList.includes(baseName);
          if (wasPinned) newPinnedList = newPinnedList.filter(name => name !== baseName);
          
          showProgress();
          try {
              const response = await fetch(notePath, { method: 'DELETE' });

              if (response.ok || response.status === 204 || response.status === 202) {
                  if(showToast) M.toast({html: `Nota borrada permanentemente.`, classes: 'green'});
                  allNotesDataMap.delete(noteFullName);
                  if (wasPinned) await savePinnedNotesToServer(newPinnedList);
                  displaySortedNotes(Array.from(allNotesDataMap.values()));
              } else {
                  throw new Error(`Error: ${response.status}`);
              }
          } catch (error) {
              if(showToast) M.toast({html: `${error.message || 'Error de red.'}`, classes: 'red'});
          } finally {
              hideProgress();
          }
        }
        
        function displayTagsInSidebar(tags) { 
          const tagsListElement = document.getElementById('tags-list');
          if (!tagsListElement) return;
          const fragment = document.createDocumentFragment();
          tags.forEach(tag => {
            const listItem = document.createElement('li'); 
            const link = document.createElement('a');
            link.href = '#!';
            link.className = 'waves-effect';
            link.innerHTML = `<i class="material-icons">label_outline</i>${tag.charAt(0).toUpperCase() + tag.slice(1)} <span class="sidebar-item-count" data-tag-count="${tag}"></span>`;
            link.dataset.tag = tag; 
            listItem.appendChild(link); 
            fragment.appendChild(listItem);
          });
          tagsListElement.replaceChildren(fragment);
        }
        
        const debounce = (func, wait) => {
          let timeout;
          return function executedFunction(...args) {
            const later = () => { clearTimeout(timeout); func(...args); };
            clearTimeout(timeout); timeout = setTimeout(later, wait);
          };
        }
        function filterNotes() {
            lastJumpedNoteIndex = -1;
            const term = universalNoteInput.value.trim().toLowerCase();
            const paginationContainer = document.getElementById('pagination-container');

            if (term === "") {
                if (paginationContainer) paginationContainer.style.display = 'block';
                displaySortedNotes(Array.from(allNotesDataMap.values()));
                return;
            }
            
            if (paginationContainer) paginationContainer.style.display = 'none';

            let searchResults = Array.from(allNotesDataMap.values()).filter(noteData => {
                let inView = false;
                switch (currentView) {
                    case 'archive': inView = noteData.isArchived && !noteData.isTrashed; break;
                    case 'trash': inView = noteData.isTrashed; break;
                    case 'untagged': inView = !noteData.isArchived && !noteData.isTrashed && noteData.tags.length === 0; break;
                    default: inView = !noteData.isArchived && !noteData.isTrashed;
                }
                if (!inView) return false;

                const fullTextMatch = isSearchIndexReady && noteData.textContentForSearch.includes(term);
                return noteData.displayName.toLowerCase().includes(term) ||
                    noteData.tags.some(t => t.toLowerCase().includes(term)) ||
                    (term.startsWith('#') && noteData.tags.some(t => t.toLowerCase().includes(term.substring(1)))) ||
                    fullTextMatch;
            });

            notesGridContainer.innerHTML = '';
            const fragment = document.createDocumentFragment();
            if (searchResults.length === 0) {
                const p = document.createElement('p');
                p.style.textAlign = 'center';
                p.style.color = 'var(--text-muted)';
                p.textContent = 'No se encontraron notas...';
                fragment.appendChild(p);
            } else {
                searchResults
                    .sort((a,b) => b.date - a.date)
                    .forEach(fileData => {
                        fragment.appendChild(createNoteCardElement(fileData));
                    });
            }
            notesGridContainer.appendChild(fragment);
            addCopyButtonsToCodeBlocks(notesGridContainer);
            notesCountElement.textContent = `${searchResults.length} nota(s) encontradas.`;
        }

        const debouncedFilterNotes = debounce(filterNotes, 200);
        
        async function updateNoteTagsFromPopup() {
            if (!tagSuggestionPopup || !currentEditingNoteName) return;

            const selectedTags = Array.from(tagSuggestionPopup.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.dataset.tag);
            const currentNoteData = findNoteDataByDecodedName(currentEditingNoteName);
            if (!currentNoteData) return;

            const currentTagsSet = new Set(currentNoteData.tags);
            const selectedTagsSet = new Set(selectedTags);
            if (currentTagsSet.size === selectedTagsSet.size && [...currentTagsSet].every(tag => selectedTagsSet.has(tag))) {
                return; 
            }
            
            const newBaseName = buildBaseFilename(currentNoteData.displayName, selectedTags, currentNoteData.color, currentNoteData.isArchived, currentNoteData.isTrashed);

            if (newBaseName !== currentNoteData.name) {
                const renamedNoteData = await renameNote(currentNoteData, newBaseName);
                if (renamedNoteData) {
                    allNotesDataMap.delete(currentNoteData.fullName);
                    allNotesDataMap.set(renamedNoteData.fullName, renamedNoteData);
                    currentEditingNoteName = renamedNoteData.name;
                    displaySortedNotes(Array.from(allNotesDataMap.values()));
                }
            }
        }

        function handleOutsideTagPopupClick(event) {
            if (tagSuggestionPopup && !tagSuggestionPopup.contains(event.target)) {
                closeTagSuggestionPopup(true);
            }
        }

        function closeTagSuggestionPopup(applyChanges = true) {
            if (tagSuggestionPopup) {
                if (applyChanges) {
                    updateNoteTagsFromPopup();
                }
                tagSuggestionPopup.remove();
                tagSuggestionPopup = null;
                document.removeEventListener('click', handleOutsideTagPopupClick, true);
            }
        }

        function showTagSuggestionPopup() {
          if (tagSuggestionPopup) return;
          closeTagSuggestionPopup(false);

          const currentNoteData = findNoteDataByDecodedName(currentEditingNoteName);
          const currentTags = currentNoteData ? currentNoteData.tags.map(t => t.toLowerCase()) : [];

          tagSuggestionPopup = document.createElement('div');
          tagSuggestionPopup.id = 'tag-suggestion-popup';
          
          let popupHTML = `
              <div class="tag-suggestion-header">Etiquetar nota</div>
              <div class="input-field" style="padding: 0 12px; margin-top: 8px;">
                  <input id="tag-suggestion-filter" type="text" placeholder="Buscar o crear etiqueta..." style="height: 2rem; font-size: 14px; border-bottom: 1px solid var(--border-color) !important; box-shadow: none !important;">
              </div>
              <ul id="tag-suggestion-list"></ul>`;
          tagSuggestionPopup.innerHTML = popupHTML;
          
          const parentElement = modalEditorContainer.classList.contains('hidden') ? 
                                document.querySelector(`.note-card[data-file-name="${currentEditingNoteName}"]`) :
                                modalEditorContainer;

          parentElement.appendChild(tagSuggestionPopup);

          if (modalEditorContainer.classList.contains('hidden')) {
              tagSuggestionPopup.style.bottom = '45px';
              tagSuggestionPopup.style.left = '45px';
          } else {
              tagSuggestionPopup.style.bottom = '50px';
              tagSuggestionPopup.style.left = '50px';
          }
          
          const filterInput = tagSuggestionPopup.querySelector('#tag-suggestion-filter');
          const list = tagSuggestionPopup.querySelector('#tag-suggestion-list');

          const renderList = () => {
              const filterText = filterInput.value.toLowerCase();
              let exactMatchFound = false;
              let listContent = '';

              Array.from(allUniqueTags).sort().forEach(tag => {
                  const isChecked = currentTags.includes(tag.toLowerCase());
                  if(tag.toLowerCase().includes(filterText)) {
                      listContent += `
                      <li class="tag-item">
                          <label>
                              <input type="checkbox" class="filled-in" data-tag="${tag}" ${isChecked ? 'checked' : ''} />
                              <span>${tag}</span>
                          </label>
                      </li>`;
                  }
                  if (tag.toLowerCase() === filterText) exactMatchFound = true;
              });
              
              list.innerHTML = listContent;

              let createOption = list.querySelector('.create-new-tag-option');
              if (createOption) createOption.remove();

              const newTag = sanitizeForFilenamePart(filterText, true);
              if (newTag && !exactMatchFound) {
                  createOption = document.createElement('li');
                  createOption.className = 'create-new-tag-option';
                  createOption.innerHTML = `<span><i class="material-icons">add</i>Crear etiqueta: "${newTag}"</span>`;
                  createOption.onclick = () => {
                      if (allUniqueTags.has(newTag.toLowerCase())) return;
                      allUniqueTags.add(newTag.toLowerCase());
                      displayTagsInSidebar(Array.from(allUniqueTags).sort());
                      
                      const newLi = document.createElement('li');
                      newLi.className = 'tag-item';
                      newLi.innerHTML = `<label><input type="checkbox" class="filled-in" data-tag="${newTag}" checked /><span>${newTag}</span></label>`;
                      list.insertBefore(newLi, list.firstChild);
                      
                      filterInput.value = '';
                      renderList();
                      filterInput.focus();
                  };
                  list.appendChild(createOption);
              }
          };

          filterInput.addEventListener('input', renderList);
          filterInput.focus();
          renderList();

          setTimeout(() => { document.addEventListener('click', handleOutsideTagPopupClick, true); }, 0);
        }
        
        async function renameNote(noteData, newBaseName) {
          showProgress();
          try {
              const newFullName = newBaseName + ".html";
              const destinationUrl = new URL(webdavNotesUrl + encodeURIComponent(newFullName), window.location.origin).href;
              const moveResponse = await fetch(noteData.path, { method: 'MOVE', headers: { 'Destination': destinationUrl, 'Overwrite': 'F' } });

              if (!moveResponse.ok && !/20[0-9]/.test(moveResponse.status)) throw new Error(`Error ${moveResponse.status}`);
              
              if(isNotePinned(noteData.name)) {
                  const newPinnedList = currentPinnedNotesList.map(name => name === noteData.name ? newBaseName : name);
                  await savePinnedNotesToServer(newPinnedList);
              }
              
              const newNoteData = { ...noteData };
              newNoteData.name = newBaseName;
              newNoteData.fullName = newFullName;
              newNoteData.path = destinationUrl;
              Object.assign(newNoteData, parseNoteFilename(newBaseName));
              return newNoteData;

          } catch(err) {
              M.toast({ html: `Error al renombrar: ${err.message}`, classes: 'red' });
              return null;
          } finally {
              hideProgress();
          }
        }
        
        async function duplicateNote(originalNoteData) {
          showProgress();
          try {
              M.toast({html: 'Creando copia...', displayLength: 2000});

              let content = originalNoteData.content;
              if (!content) {
                  const response = await fetch(originalNoteData.path);
                  if (!response.ok) throw new Error(`Error al leer la nota original: ${response.status}`);
                  content = await response.text();
              }

              let newDisplayName;
              let newBaseName;
              let newPath;
              let counter = 0;
              let isUnique = false;

              while (!isUnique) {
                  counter++;
                  newDisplayName = `Copia de ${originalNoteData.displayName}${counter > 1 ? ` (${counter})` : ''}`;
                  newBaseName = buildBaseFilename(newDisplayName, originalNoteData.tags, originalNoteData.color, originalNoteData.isArchived, originalNoteData.isTrashed);
                  newPath = webdavNotesUrl + encodeURIComponent(newBaseName) + ".html";

                  if (!findNoteDataByDecodedName(newBaseName)) {
                      isUnique = true;
                  }
              }
              
              const newContent = content.replace(/<title>.*<\/title>/, `<title>${newDisplayName}</title>`);
              
              const putResponse = await fetch(newPath, {
                  method: 'PUT',
                  headers: { 'Content-Type': 'text/html; charset=UTF-8' },
                  body: newContent
              });

              if (putResponse.ok || putResponse.status === 201 || putResponse.status === 204) {
                   M.toast({html: 'Nota copiada con éxito.', classes: 'green'});
                   await fetchNotesAndDisplayCards();
              } else {
                  throw new Error(`Error al crear la copia: ${putResponse.status}`);
              }

          } catch (error) {
              M.toast({html: `Error: ${error.message}`, classes: 'red'});
          } finally {
              hideProgress();
          }
      }

      function sanitizePastedHtml(htmlString) {
          const doc = contentParser.parseFromString(htmlString, 'text/html');
          const allElements = doc.body.querySelectorAll('*');

          allElements.forEach(el => {
              if (el.style) {
                  el.style.removeProperty('background-color');
                  el.style.removeProperty('background');
              }
              if (el.hasAttribute('bgcolor')) {
                  el.removeAttribute('bgcolor');
              }
          });

          return doc.body.innerHTML;
      }
      
      async function saveBackupCopyForNote(noteData) {
          if (!noteData) return;
          const versionsDir = webdavNotesUrl + ".versiones/";
          try {
              const mkcolResponse = await fetch(versionsDir, { method: 'MKCOL' });
          } catch(e) { }
          
          const now = new Date();
          const pad = (num) => num.toString().padStart(2, '0');
          const timestamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
          const backupFileName = `${timestamp}-${noteData.name}.html`;
          const backupFilePath = versionsDir + encodeURIComponent(backupFileName);
          try {
              let contentToSave = noteData.content;
              if (!contentToSave) {
                   const response = await fetch(noteData.path);
                   if(response.ok) contentToSave = await response.text();
              }
              if (contentToSave) {
                  await fetch(backupFilePath, {
                      method: 'PUT',
                      headers: { 'Content-Type': 'text/html; charset=UTF-8' },
                      body: contentToSave
                  });
              }
          } catch (error) {
          }
      }

        async function saveNoteFromEditor(contentToSave) {
            if (saveInProgress || !currentEditingNoteName) return;
            
            const currentNoteData = findNoteDataByDecodedName(currentEditingNoteName);
            if (!currentNoteData) {
                M.toast({ html: 'Error: No se encontraron datos de la nota original.', classes: 'red' });
                return;
            }
            
            if(initialEditorState.content.startsWith(ENCRYPTION_PREFIX) && !isEditingEncryptedNote) {
                console.log("Save blocked: encrypted note not in edit mode.");
                return; // Block saving
            }
            
            saveInProgress = true;
            showProgress();
            
            await saveBackupCopyForNote(currentNoteData);

            let htmlContentFromEditor = contentToSave;
            
            const titleWithTags = modalTitleInput.value.trim();
            const tagRegex = /\B#([a-zA-Z0-9\-_]+)/g;

            const titleTagMatches = titleWithTags.match(tagRegex) || [];
            const tagsFromTitle = new Set(titleTagMatches.map(tagWithHash => sanitizeForFilenamePart(tagWithHash.substring(1), true)));
            
            const allTags = new Set([...tagsFromTitle]);

            const finalDisplayName = sanitizeForFilenamePart(titleWithTags.replace(tagRegex, '').trim(), false) || "Nota";
            
            const finalHtmlContentToSave = sanitizePastedHtml(htmlContentFromEditor);

            const newColor = currentNoteData.color;
            const newBaseName = buildBaseFilename(finalDisplayName, Array.from(allTags), newColor, currentNoteData.isArchived, currentNoteData.isTrashed);
            
            const needsRename = newBaseName !== currentEditingNoteName;
            const oldFileAbsolutePath = currentNoteData.path;

            try {
                const putResponse = await fetch(oldFileAbsolutePath, { method: 'PUT', headers: { 'Content-Type': 'text/html; charset=UTF-8' }, body: finalHtmlContentToSave });
                if (!putResponse.ok && !/20[0-9]/.test(putResponse.status)) throw new Error(`Error al guardar: ${putResponse.status}`);

                if (needsRename) {
                    const renamedNoteData = await renameNote(currentNoteData, newBaseName);
                    if (renamedNoteData) {
                        currentEditingNoteName = renamedNoteData.name;
                    } else {
                        throw new Error("Fallo el renombrado.");
                    }
                }
                M.toast({ html: 'Nota guardada.', classes: 'green', displayLength: 2000 });
                initialEditorState = { title: titleWithTags, content: htmlContentFromEditor };
            } catch (err) {
                M.toast({ html: `Error crítico: ${err.message}`, classes: 'red', displayLength: 5000 });
            } finally {
                saveInProgress = false;
                hideProgress();
            }
        }

        function showEditTagsModal() {
          closeSidebar();
          populateEditTagsModal();
          editTagsModal.classList.remove('hidden');
          editTagsModalOverlay.classList.remove('hidden');
          document.body.classList.add('modal-active');
        }

        function hideEditTagsModal() {
            editTagsModal.classList.add('hidden');
            editTagsModalOverlay.classList.add('hidden');
            document.body.classList.remove('modal-active');
        }

        function populateEditTagsModal() {
            const listElement = document.getElementById('editable-tags-list');
            listElement.innerHTML = '';
            const sortedTags = Array.from(allUniqueTags).sort();

            sortedTags.forEach(tag => {
                const li = document.createElement('li');
                li.dataset.tag = tag;
                li.innerHTML = `
                    <div class="tag-name-container">
                        <i class="material-icons">label_outline</i>
                        <span class="tag-name">${tag}</span>
                    </div>
                    <i class="material-icons edit-tag-btn">edit</i>`;
                listElement.appendChild(li);
            });
        }
        
        async function handleNoteStateChange(noteData, state) {
          const isArchiving = state === 'archivada';
          const isTrashing = state === 'papelera';

          const newBaseName = buildBaseFilename(noteData.displayName, noteData.tags, noteData.color, isArchiving, isTrashing);
          
          if (newBaseName === noteData.name) return;

          const cardElement = document.querySelector(`.note-card[data-full-name="${noteData.fullName}"]`);
          if (cardElement) {
              cardElement.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
              cardElement.style.opacity = '0';
              cardElement.style.transform = 'scale(0.95)';
              setTimeout(() => cardElement.remove(), 300);
          }
          
          let msg = 'Nota actualizada.';
          if (isArchiving) msg = 'Nota archivada.';
          if (isTrashing) msg = 'Nota movida a la papelera.';
          if (state === 'notes') msg = 'Nota restaurada.';
          M.toast({ html: msg, classes: 'green' });
          
          try {
              const renamedNoteData = await renameNote(noteData, newBaseName);
              if (!renamedNoteData) throw new Error("El renombrado falló.");
              
              allNotesDataMap.delete(noteData.fullName);
              allNotesDataMap.set(renamedNoteData.fullName, renamedNoteData);
              updateSidebarCounts();

          } catch (error) {
               M.toast({ html: `Error: ${error.message}. Restaurando nota.`, classes: 'red' });
               displaySortedNotes(Array.from(allNotesDataMap.values()));
               updateSidebarCounts();
          }
        }

        async function renameTag(oldTag, newTag) {
            oldTag = oldTag.trim().toLowerCase();
            newTag = sanitizeForFilenamePart(newTag.trim(), true);

            if (!newTag) { M.toast({html: 'El nombre de la etiqueta no es válido.', classes: 'red'}); return; }
            if (newTag.toLowerCase() === oldTag) return;
            if (allUniqueTags.has(newTag.toLowerCase())) { M.toast({html: 'La etiqueta ya existe.', classes: 'red'}); return; }

            const notesToUpdate = Array.from(allNotesDataMap.values()).filter(note => 
                note.tags.map(t => t.toLowerCase()).includes(oldTag)
            );

            M.toast({html: `Actualizando ${notesToUpdate.length} nota(s)...`, displayLength: 60000});
            showProgress();

            let errors = 0;
            let successfulRenames = [];

            for (const noteData of notesToUpdate) {
                const newTags = noteData.tags.map(t => (t.toLowerCase() === oldTag) ? newTag : t);
                const newBaseName = buildBaseFilename(noteData.displayName, newTags, noteData.color, noteData.isArchived, noteData.isTrashed);
                if (newBaseName !== noteData.name) {
                    const renamed = await renameNote(noteData, newBaseName);
                    if(!renamed) {
                      errors++;
                    } else {
                      successfulRenames.push({ oldFullName: noteData.fullName, newData: renamed });
                    }
                }
            }
            
            hideProgress();
            M.Toast.dismissAll();
            if (errors > 0) M.toast({html: `Se produjeron ${errors} errores.`, classes: 'red'});
            else M.toast({html: 'Etiqueta renombrada con éxito.', classes: 'green'});
            
            successfulRenames.forEach(op => {
                allNotesDataMap.delete(op.oldFullName);
                allNotesDataMap.set(op.newData.fullName, op.newData);
            });

            allUniqueTags.delete(oldTag);
            allUniqueTags.add(newTag);

            displaySortedNotes(Array.from(allNotesDataMap.values()));
            displayTagsInSidebar(Array.from(allUniqueTags).sort());
            updateSidebarCounts();
            populateEditTagsModal();
        }
        
        function setActiveSidebarItem(activeElement) {
          document.querySelectorAll('#sidebar-menu li a').forEach(el => el.classList.remove('active'));
          if (activeElement) {
              activeElement.classList.add('active');
          }
        }
        
        function toggleSelection(cardElement) {
          const noteName = cardElement.dataset.fileName;
          if (selectedNotes.has(noteName)) {
              selectedNotes.delete(noteName);
              cardElement.classList.remove('selected');
          } else {
              selectedNotes.add(noteName);
              cardElement.classList.add('selected');
          }
          updateMultiSelectBarVisibility();
        }

        function updateMultiSelectBarVisibility() {
          const count = selectedNotes.size;
          const reorderUpBtn = document.querySelector('[data-action="multi-reorder-up"]');
          const reorderDownBtn = document.querySelector('[data-action="multi-reorder-down"]');
          const reorderSeparator = document.getElementById('multi-reorder-separator');

          if (count > 0) {
              selectionCount.textContent = `${count} seleccionada(s)`;
              multiSelectActionBar.classList.add('visible');
              document.body.classList.add('multi-select-active');

              if (count === 1) {
                  const singleSelectedNoteName = selectedNotes.values().next().value;
                  if (isNotePinned(singleSelectedNoteName)) {
                      reorderUpBtn.classList.remove('hidden');
                      reorderDownBtn.classList.remove('hidden');
                      reorderSeparator.classList.remove('hidden');
                  } else {
                      reorderUpBtn.classList.add('hidden');
                      reorderDownBtn.classList.add('hidden');
                      reorderSeparator.classList.add('hidden');
                  }
              } else {
                  reorderUpBtn.classList.add('hidden');
                  reorderDownBtn.classList.add('hidden');
                  reorderSeparator.classList.add('hidden');
              }

          } else {
              multiSelectActionBar.classList.remove('visible');
              document.body.classList.remove('multi-select-active');
              reorderUpBtn.classList.add('hidden');
              reorderDownBtn.classList.add('hidden');
              reorderSeparator.classList.add('hidden');
          }
        }

        function clearSelection() {
          selectedNotes.clear();
          document.querySelectorAll('.note-card.selected').forEach(card => card.classList.remove('selected'));
          updateMultiSelectBarVisibility();
        }

        async function handleMultiAction(state) {
          const selectedNoteData = Array.from(selectedNotes).map(noteName => findNoteDataByDecodedName(noteName)).filter(Boolean);
          const isArchiving = state === 'archivada';
          const isTrashing = state === 'papelera';
          
          selectedNoteData.forEach(noteData => {
              const cardElement = document.querySelector(`.note-card[data-full-name="${noteData.fullName}"]`);
              if (cardElement) cardElement.remove();
          });
          M.toast({html: `${selectedNoteData.length} nota(s) actualizadas.`, classes: 'green'});
          
          showProgress();
          const promises = selectedNoteData.map(noteData => {
              const newBaseName = buildBaseFilename(noteData.displayName, noteData.tags, noteData.color, isArchiving, isTrashing);
              return renameNote(noteData, newBaseName);
          });

          try {
              const results = await Promise.all(promises);
              results.forEach((renamedNoteData, index) => {
                  if (renamedNoteData) {
                      allNotesDataMap.delete(selectedNoteData[index].fullName);
                      allNotesDataMap.set(renamedNoteData.fullName, renamedNoteData);
                  }
              });
              updateSidebarCounts();
          } catch (error) {
              M.toast({html: 'Ocurrió un error al actualizar algunas notas.', classes: 'red'});
              await fetchNotesAndDisplayCards();
          } finally {
              clearSelection();
              hideProgress();
          }
        }

        async function handleMultiPinAction() {
          const notesToPin = Array.from(selectedNotes)
              .map(noteName => findNoteDataByDecodedName(noteName))
              .filter(noteData => noteData && !noteData.isPinned);

          if (notesToPin.length === 0) {
              M.toast({html: 'Todas las notas seleccionadas ya están fijadas.', classes: 'blue'});
              return;
          }

          const originalPinnedList = [...currentPinnedNotesList];
          const newPins = notesToPin.map(n => n.name);
          const newPinnedList = [...newPins, ...originalPinnedList];

          notesToPin.forEach(noteData => {
              noteData.isPinned = true;
          });
          currentPinnedNotesList = newPinnedList;
          displaySortedNotes(Array.from(allNotesDataMap.values()));
          M.toast({html: `${notesToPin.length} nota(s) fijada(s).`, classes: 'green'});
          
          try {
              await savePinnedNotesToServer(newPinnedList);
          } catch (error) {
              M.toast({html: `Error al fijar notas: ${error.message}`, classes: 'red'});
              currentPinnedNotesList = originalPinnedList;
              notesToPin.forEach(noteData => { noteData.isPinned = false; });
              displaySortedNotes(Array.from(allNotesDataMap.values()));
          } finally {
              clearSelection();
          }
        }

        async function handleMultiColorChange(newColor) {
          const selectedNoteData = Array.from(selectedNotes).map(noteName => findNoteDataByDecodedName(noteName)).filter(Boolean);
          
          selectedNoteData.forEach(noteData => {
              const cardElement = document.querySelector(`.note-card[data-full-name="${noteData.fullName}"]`);
              if (cardElement) applyColorToCard(cardElement, newColor);
          });
          
          showProgress();
          const promises = selectedNoteData.map(noteData => {
              const newBaseName = buildBaseFilename(noteData.displayName, noteData.tags, newColor, noteData.isArchived, noteData.isTrashed);
              return renameNote(noteData, newBaseName);
          });

          try {
              const results = await Promise.all(promises);
              M.toast({html: `Color cambiado para ${results.length} nota(s).`, classes: 'green'});
              results.forEach((renamedNoteData, index) => {
                  if (renamedNoteData) {
                      allNotesDataMap.delete(selectedNoteData[index].fullName);
                      allNotesDataMap.set(renamedNoteData.fullName, renamedNoteData);
                  }
              });
          } catch(e) {
              M.toast({html: 'Error al cambiar color.', classes: 'red'});
              await fetchNotesAndDisplayCards();
          } finally {
              clearSelection();
              hideProgress();
          }
        }
        
        function showHelpModal() {
          helpModal.classList.remove('hidden');
          helpModalOverlay.classList.remove('hidden');
          document.body.classList.add('modal-active');
        }

        function hideHelpModal() {
            helpModal.classList.add('hidden');
            helpModalOverlay.classList.add('hidden');
            document.body.classList.remove('modal-active');
        }

        function updateSidebarCounts() {
          let archiveCount = 0;
          let trashCount = 0;
          const tagCounts = {};
          let totalNotes = 0;

          for (const note of allNotesDataMap.values()) {
              if (note.isArchived) archiveCount++;
              if (note.isTrashed) trashCount++;
              if (!note.isArchived && !note.isTrashed) {
                totalNotes++;
              }
              note.tags.forEach(tag => {
                  tagCounts[tag] = (tagCounts[tag] || 0) + 1;
              });
          }
          
          const allNotesCountEl = document.getElementById('all-notes-count');
          if (allNotesCountEl) {
              allNotesCountEl.textContent = totalNotes > 0 ? totalNotes : '';
              allNotesCountEl.style.display = totalNotes > 0 ? 'inline-block' : 'none';
          }

          const archiveCountEl = document.getElementById('archive-count');
          archiveCountEl.textContent = archiveCount > 0 ? archiveCount : '';
          archiveCountEl.style.display = archiveCount > 0 ? 'inline-block' : 'none';

          const trashCountEl = document.getElementById('trash-count');
          trashCountEl.textContent = trashCount > 0 ? trashCount : '';
          trashCountEl.style.display = trashCount > 0 ? 'inline-block' : 'none';

          document.querySelectorAll('[data-tag-count]').forEach(el => {
              const tag = el.dataset.tagCount;
              const count = tagCounts[tag] || 0;
              el.textContent = count > 0 ? count : '';
              el.style.display = count > 0 ? 'inline-block' : 'none';
          });
        }

        createNoteIconButton.addEventListener('click', () => addNewNote());
        clearFilterButton.addEventListener('click', () => {
            universalNoteInput.value = '';
            setActiveSidebarItem(allNotesBtn);
            universalNoteInput.focus();
            displaySortedNotes(Array.from(allNotesDataMap.values()));
        });

        refreshNotesIconButton.addEventListener('click', () => {
            fetchNotesAndDisplayCards(); M.toast({html: 'Lista actualizada', classes:'blue lighten-2'});
        });

        universalNoteInput.addEventListener('input', () => {
            if(universalNoteInput.value.trim() === '') {
                displaySortedNotes(Array.from(allNotesDataMap.values()));
            } else {
                debouncedFilterNotes();
            }

            if(universalNoteInput.value.trim() !== '') {
                const currentTag = universalNoteInput.value.trim().toLowerCase();
                if(currentTag.startsWith('#')) {
                    const tagLink = document.querySelector(`#sidebar-menu a[data-tag="${currentTag.substring(1)}"]`);
                    setActiveSidebarItem(tagLink);
                } else {
                     setActiveSidebarItem(null);
                }
            } else {
                setActiveSidebarItem(allNotesBtn);
            }
        });

        universalNoteInput.addEventListener('keypress', (e) => { 
            if (e.key === 'Enter') { 
                e.preventDefault(); 
                addNewNote(); 
            }
        });
        
        closeEditorLink.addEventListener('click', hideEditorView);
        modalOverlay.addEventListener('click', hideEditorView);
        
         notesGridContainer.addEventListener('mousedown', (e) => {
             clearTimeout(longPressTimer);
             const card = e.target.closest('.note-card');
             if (!card) return;
             isLongPress = false;
             longPressTimer = setTimeout(() => {
                 isLongPress = true;
                 toggleSelection(card);
             }, 500);
         });
         
         notesGridContainer.addEventListener('mouseup', (e) => {
             clearTimeout(longPressTimer);
         });
         
         notesGridContainer.addEventListener('mouseleave', (e) => {
             const card = e.target.closest('.note-card');
             if(card) clearTimeout(longPressTimer);
         }, true);

        notesGridContainer.addEventListener('click', (e) => {
          if(isLongPress) {
              e.preventDefault();
              return;
          }

          const card = e.target.closest('.note-card');
          if (!card) return;
          
          const actionTarget = e.target.closest('[data-action]');
          
          if (selectedNotes.size > 0 && !actionTarget) {
              toggleSelection(card);
              return;
          }

          const noteBaseName = card.dataset.fileName;
          const noteFullName = card.dataset.fullName;
          const fileData = allNotesDataMap.get(noteFullName);
          
          if (actionTarget) {
              e.stopPropagation();
              const action = actionTarget.dataset.action;
              switch (action) {
                  case 'pin': togglePinStatus(noteBaseName); break;
                  case 'reorder-up': reorderPinnedNote(noteBaseName, 'up'); break;
                  case 'reorder-down': reorderPinnedNote(noteBaseName, 'down'); break;
                  case 'copy':
                      if (fileData) {
                          const copyNoteContent = (htmlContent) => {
                              const textToCopy = htmlToStructuredText(htmlContent);
                              navigator.clipboard.writeText(textToCopy).then(() => {
                                  M.toast({html: 'Contenido copiado.'});
                              }).catch(err => {
                                  M.toast({html: 'Error al copiar.', classes: 'red'});
                              });
                          };

                          if (fileData.content) {
                              copyNoteContent(fileData.content);
                          } else {
                              fetch(fileData.path)
                                  .then(res => res.ok ? res.text() : Promise.reject('Error fetching note'))
                                  .then(html => {
                                      fileData.content = html;
                                      copyNoteContent(html);
                                  })
                                  .catch(err => M.toast({html: 'No se pudo cargar la nota para copiar.', classes: 'red'}));
                          }
                      }
                      break;
                  case 'clean-format':
                      handleCleanFormat(fileData, card);
                      break;
                  case 'manage-tags':
                      currentEditingNoteName = noteBaseName;
                      showTagSuggestionPopup();
                      break;
                  case 'archive': handleNoteStateChange(fileData, 'archivada'); break;
                  case 'unarchive': handleNoteStateChange(fileData, 'notes'); break;
                  case 'trash': handleNoteStateChange(fileData, 'papelera'); break;
                  case 'restore': handleNoteStateChange(fileData, 'notes'); break;
                  case 'delete-permanent': if (confirm(`¿Borrar "${fileData.displayName}" permanentemente? Esta acción no se puede deshacer.`)) permanentlyDeleteNote(noteFullName, baseName, true); break;
                  case 'change-color': if (fileData) toggleColorPalettePanel(card, fileData, actionTarget.closest('button')); break;
              }
          } else {
               showEditorView(noteBaseName);
          }
        });
        
        pinModalBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          const noteData = findNoteDataByDecodedName(currentEditingNoteName);
          if (noteData) {
              await togglePinStatus(noteData.name);
              const updatedNoteData = findNoteDataByDecodedName(currentEditingNoteName);
              pinModalBtn.classList.toggle('pinned', updatedNoteData.isPinned);
              const instance = M.Tooltip.getInstance(pinModalBtn);
              instance.options.tooltip = updatedNoteData.isPinned ? 'Quitar fijación' : 'Fijar';
          }
      });
      
      archiveModalBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const noteData = findNoteDataByDecodedName(currentEditingNoteName);
          if (noteData) {
              hideEditorView();
              handleNoteStateChange(noteData, 'archivada');
          }
      });

      manageTagsModalBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          showTagSuggestionPopup();
      });

      trashModalBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          const noteData = findNoteDataByDecodedName(currentEditingNoteName);
          if (noteData) {
              hideEditorView();
              handleNoteStateChange(noteData, 'papelera');
          }
      });
      
      cleanFormatOption.addEventListener('click', (e) => {
          e.preventDefault();
          if(confirm("Esto eliminará todos los colores y estilos del contenido. ¿Continuar?")) {
              const currentContent = noteEditorContentEditable.innerHTML;
              const cleanedContent = cleanNoteFormatting(currentContent);
              noteEditorContentEditable.innerHTML = cleanedContent;
              M.toast({html: 'Formato limpiado. Cierra para guardar los cambios.'});
          }
          M.Dropdown.getInstance(document.getElementById('more-options-dropdown')).close();
      });

      changeColorOption.addEventListener('click', (e) => {
          e.preventDefault();
          const noteData = findNoteDataByDecodedName(currentEditingNoteName);
          if(noteData) {
            toggleColorPalettePanel(modalEditorContainer, noteData, document.getElementById('more-options-modal-btn'));
          }
          M.Dropdown.getInstance(document.getElementById('more-options-dropdown')).close();
      });
        
        fullscreenModalBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          modalEditorContainer.classList.toggle('fullscreen-mode');

          const isFullscreen = modalEditorContainer.classList.contains('fullscreen-mode');
          const iconElement = fullscreenModalBtn.querySelector('.material-icons');
          const tooltipInstance = M.Tooltip.getInstance(fullscreenModalBtn);

          if (isFullscreen) {
              iconElement.textContent = 'fullscreen_exit';
              tooltipInstance.options.tooltip = 'Salir de pantalla completa';
          } else {
              iconElement.textContent = 'fullscreen';
              tooltipInstance.options.tooltip = 'Pantalla completa';
          }
        });

        duplicateNoteOption.addEventListener('click', (e) => {
          e.preventDefault();
          const noteData = findNoteDataByDecodedName(currentEditingNoteName);
          if (noteData) {
              duplicateNote(noteData);
          }
          var instance = M.Dropdown.getInstance(document.getElementById('more-options-dropdown'));
          if (instance) instance.close();
        });

        copyAsTextOption.addEventListener('click', (e) => {
          e.preventDefault();
          const content = noteEditorContentEditable.innerHTML;
          const textToCopy = htmlToStructuredText(unprocessWikilinks(content));
          
          navigator.clipboard.writeText(textToCopy).then(() => {
              M.toast({html: 'Nota copiada como texto.', classes: 'green'});
          }).catch(err => {
              M.toast({html: 'Error al copiar.', classes: 'red'});
          });
          
          var instance = M.Dropdown.getInstance(document.getElementById('more-options-dropdown'));
          if (instance) instance.close();
        });
        
        historyOption.addEventListener('click', (e) => {
          e.preventDefault();
          openHistoryModalForNote();
          var instance = M.Dropdown.getInstance(document.getElementById('more-options-dropdown'));
          if (instance) instance.close();
        });

        dictationOption.addEventListener('click', (e) => {
          e.preventDefault();
          openDictationModal();
          var instance = M.Dropdown.getInstance(document.getElementById('more-options-dropdown'));
          if (instance) instance.close();
        });

        improveNoteOption.addEventListener('click', (e) => {
          e.preventDefault();
          openImproveModal();
          var instance = M.Dropdown.getInstance(document.getElementById('more-options-dropdown'));
          if (instance) instance.close();
        });

        allNotesBtn.addEventListener('click', (e) => {
          e.preventDefault();
          currentView = 'notes';
          universalNoteInput.value = '';
          displaySortedNotes(Array.from(allNotesDataMap.values()));
          setActiveSidebarItem(allNotesBtn);
          closeSidebar();
        });
        
        archiveBtn.addEventListener('click', (e) => {
          e.preventDefault();
          currentView = 'archive';
          universalNoteInput.value = '';
          displaySortedNotes(Array.from(allNotesDataMap.values()));
          setActiveSidebarItem(archiveBtn);
          closeSidebar();
        });

        trashBtn.addEventListener('click', (e) => {
          e.preventDefault();
          currentView = 'trash';
          universalNoteInput.value = '';
          displaySortedNotes(Array.from(allNotesDataMap.values()));
          setActiveSidebarItem(trashBtn);
          closeSidebar();
        });

        untaggedBtn.addEventListener('click', (e) => {
          e.preventDefault();
          currentView = 'untagged';
          universalNoteInput.value = '';
          displaySortedNotes(Array.from(allNotesDataMap.values()));
          setActiveSidebarItem(untaggedBtn);
          closeSidebar();
        });

        document.getElementById('tags-list').addEventListener('click', (e) => {
          const link = e.target.closest('a[data-tag]');
          if (link) { 
              e.preventDefault(); 
              const tag = link.dataset.tag;
              currentView = 'notes';
              universalNoteInput.value = `#${tag}`;
              debouncedFilterNotes();
              setActiveSidebarItem(link);
              closeSidebar(); 
          }
        });
        
        editTagsSidebarBtn.addEventListener('click', showEditTagsModal);
        closeEditTagsModalBtn.addEventListener('click', hideEditTagsModal);
        editTagsModalOverlay.addEventListener('click', hideEditTagsModal);

        document.getElementById('editable-tags-list').addEventListener('click', (e) => {
            const editBtn = e.target.closest('.edit-tag-btn');
            if (editBtn) {
                const li = editBtn.closest('li');
                const oldTag = li.dataset.tag;
                const nameContainer = li.querySelector('.tag-name-container');
                nameContainer.style.display = 'none';
                editBtn.style.display = 'none';

                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'tag-edit-input';
                input.value = oldTag;

                const saveBtn = document.createElement('i');
                saveBtn.className = 'material-icons';
                saveBtn.textContent = 'done';
                saveBtn.style.cursor = 'pointer';

                const cancelEditing = () => {
                    li.removeChild(input);
                    li.removeChild(saveBtn);
                    nameContainer.style.display = 'flex';
                    editBtn.style.display = 'block';
                };
                
                saveBtn.onclick = () => {
                    renameTag(oldTag, input.value);
                };
                input.onkeydown = (keyEvent) => {
                    if (keyEvent.key === 'Enter') saveBtn.click();
                    if (keyEvent.key === 'Escape') cancelEditing();
                };
                
                li.insertBefore(input, editBtn);
                li.insertBefore(saveBtn, editBtn);
                input.focus();
                input.select();
            }
        });

        function createNewTagFromModal() {
          const input = document.getElementById('create-tag-modal-input');
          const newTagRaw = input.value.trim();
          if (!newTagRaw) return;

          const newTag = sanitizeForFilenamePart(newTagRaw, true);
          if (newTag && !allUniqueTags.has(newTag.toLowerCase())) {
              allUniqueTags.add(newTag.toLowerCase());
              displayTagsInSidebar(Array.from(allUniqueTags).sort());
              populateEditTagsModal();
              M.toast({ html: `Etiqueta '${newTag}' creada.`, classes: 'green' });
          } else if (!newTag) {
              M.toast({ html: 'Nombre de etiqueta inválido.', classes: 'orange' });
          } else {
              M.toast({ html: 'La etiqueta ya existe.', classes: 'blue' });
          }
          input.value = '';
        }
        document.getElementById('confirm-create-tag-btn').addEventListener('click', createNewTagFromModal);
        document.getElementById('create-tag-modal-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') createNewTagFromModal();
        });
        document.getElementById('clear-create-tag-btn').addEventListener('click', () => {
            document.getElementById('create-tag-modal-input').value = '';
        });

        closeSelectionBtn.addEventListener('click', clearSelection);
        multiSelectActionBar.addEventListener('click', (e) => {
            const button = e.target.closest('button');
            if (!button) return;
            const action = button.dataset.action;
            
            switch (action) {
                case 'multi-archive': handleMultiAction('archivada'); break;
                case 'multi-trash': handleMultiAction('papelera'); break;
                case 'multi-pin': handleMultiPinAction(); break;
                case 'multi-color': 
                  toggleColorPalettePanel(document.body, null, button);
                  break;
                case 'multi-tag': 
                  M.toast({html: 'Funcionalidad de etiquetado múltiple no implementada aún.'});
                  break;
                // NEW EVENT HANDLING FOR REORDER
                case 'multi-reorder-up':
                case 'multi-reorder-down':
                    if (selectedNotes.size === 1) {
                        const noteName = selectedNotes.values().next().value;
                        const direction = action === 'multi-reorder-up' ? 'up' : 'down';
                        reorderPinnedNote(noteName, direction);
                    }
                    break;
            }
        });

        closeHelpModalBtn.addEventListener('click', hideHelpModal);
        helpModalOverlay.addEventListener('click', hideHelpModal);

        document.addEventListener("keydown", e => {
          const isModalOpen = !modalEditorContainer.classList.contains('hidden');
          const isAnyOverlayVisible = !helpModal.classList.contains('hidden') || 
                                      !historyModal.classList.contains('hidden') ||
                                      !globalHistoryModal.classList.contains('hidden') ||
                                      !historyPreviewModal.classList.contains('hidden') ||
                                      !createTableModal.classList.contains('hidden') ||
                                      !encryptModal.classList.contains('hidden') ||
                                      !editTagsModal.classList.contains('hidden');
          
          const activeEl = document.activeElement;
          const isInputActive = activeEl && (activeEl.tagName === 'INPUT' || activeEl.isContentEditable);
          const isEditorActive = activeEl.id === 'note-editor-contenteditable';
          const isSearchActive = activeEl.id === 'universal-note-input';

          if (e.key === "Escape") {
              e.preventDefault();
              if (modalEditorContainer.classList.contains('fullscreen-mode')) fullscreenModalBtn.click();
              else if (selectedNotes.size > 0) clearSelection();
              else if (isAnyOverlayVisible) {
                  if (!helpModal.classList.contains('hidden')) hideHelpModal();
                  if (!historyPreviewModal.classList.contains('hidden')) hideHistoryPreviewModal();
                  if (!historyModal.classList.contains('hidden')) hideHistoryModal();
                  if (!globalHistoryModal.classList.contains('hidden')) hideGlobalHistoryModal();
                  if (!createTableModal.classList.contains('hidden')) hideCreateTableModal();
                  if (!editTagsModal.classList.contains('hidden')) hideEditTagsModal();
                  if (!encryptModal.classList.contains('hidden')) hideEncryptModal();
              }
              else if (isModalOpen) hideEditorView();
              return;
          }

          if (isEditorActive && (e.ctrlKey || e.metaKey)) {
              let handled = true;
              switch (e.key.toLowerCase()) {
                  case 's': saveNoteFromEditor(); break;
                  case 'b': document.execCommand('bold'); break;
                  case 'i': document.execCommand('italic'); break;
                  case 'u': document.execCommand('underline'); break;
                  case 'k': document.execCommand('formatBlock', false, 'pre'); break;
                  case '1': document.execCommand('formatBlock', false, 'h1'); break;
                  case '2': document.execCommand('formatBlock', false, 'h2'); break;
                  case '3': document.execCommand('formatBlock', false, 'h3'); break;
                  case '4': document.execCommand('formatBlock', false, 'h4'); break;
                  case 't': addTableOption.click(); break;
                  default:
                      if (e.shiftKey) {
                          if (e.key === '&' || e.key === '7') document.execCommand('insertUnorderedList');
                          else if (e.key === '(' || e.key === '8') document.execCommand('insertOrderedList');
                          else handled = false;
                      } else {
                          handled = false;
                      }
                      break;
              }
              if (handled) e.preventDefault();
          }
          
          if (e.ctrlKey || e.metaKey) {
              if (isModalOpen && e.key.toLowerCase() === 'q') {
                  e.preventDefault();
                  hideEditorView();
              }
              if (e.key.toLowerCase() === 'h') {
                  e.preventDefault();
                  !helpModal.classList.contains('hidden') ? hideHelpModal() : showHelpModal();
              }
          }
          
          if (!isModalOpen && !isAnyOverlayVisible && (e.ctrlKey || e.metaKey)) {
               if (e.key.toLowerCase() === "f") {
                  if (!isSearchActive) {
                      e.preventDefault(); 
                      universalNoteInput.focus(); 
                      universalNoteInput.select();
                  }
              } else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                  if (!isInputActive || (isInputActive && !isSearchActive)) {
                      e.preventDefault();
                      const visibleNotes = Array.from(notesGridContainer.querySelectorAll('.note-card:not([style*="display: none"])'));
                      if (visibleNotes.length === 0) return;

                      const currentIndex = visibleNotes.findIndex(n => n.classList.contains('keyboard-focused'));
                      let nextIndex = currentIndex;

                      if (currentIndex === -1) nextIndex = 0;
                      else if (e.key === 'ArrowDown' || e.key === 'ArrowRight') nextIndex = Math.min(visibleNotes.length - 1, currentIndex + 1);
                      else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') nextIndex = Math.max(0, currentIndex - 1);

                      if (nextIndex !== currentIndex) {
                          if (currentIndex > -1) visibleNotes[currentIndex].classList.remove('keyboard-focused');
                          const nextNote = visibleNotes[nextIndex];
                          nextNote.classList.add('keyboard-focused');
                          nextNote.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                      }
                  }
              } else if (e.key === 'Enter') {
                   if (!isInputActive || (isInputActive && !isSearchActive)) {
                      e.preventDefault();
                      const noteToOpen = notesGridContainer.querySelector('.note-card.keyboard-focused');
                      if (noteToOpen) {
                          showEditorView(noteToOpen.dataset.fileName);
                      }
                  }
              }
          }
        });
        
        const reorderHandlesHTML = `
          <div class="reorder-handles">
              <i class="material-icons reorder-up">arrow_upward</i>
              <i class="material-icons reorder-down">arrow_downward</i>
              <i class="material-icons reorder-delete" style="color:#d32f2f;">remove_circle_outline</i>
          </div>`;

        addChecklistModalBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            noteEditorContentEditable.focus();
            const uniqueId = `task-${Date.now()}`;
            const checklistHtml = `
                <ul class="checklist">
                    <li>
                        <i class="material-icons checklist-box">check_box_outline_blank</i><div class="checklist-text" id="${uniqueId}"><br></div>${reorderHandlesHTML}
                    </li>
                </ul><p><br></p>`;
            
            document.execCommand('insertHTML', false, checklistHtml);
            const newTextElement = noteEditorContentEditable.querySelector(`#${uniqueId}`);
            if (newTextElement) {
                newTextElement.removeAttribute('id');
                const range = document.createRange();
                const sel = window.getSelection();
                range.setStart(newTextElement, 0);
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);
            }
        });
        
        reorderChecklistBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const editor = noteEditorContentEditable;
            const isEnteringReorderMode = !editor.classList.contains('reorder-mode');
            editor.classList.toggle('reorder-mode');

            if (isEnteringReorderMode) {
                const checklistItems = editor.querySelectorAll('ul.checklist > li');
                checklistItems.forEach(li => {
                    if (!li.querySelector('.reorder-handles')) {
                        li.insertAdjacentHTML('beforeend', reorderHandlesHTML);
                    }
                });
            }
        });
        
        markdownToggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            modalEditorContainer.classList.toggle('markdown-active');
            const isActive = modalEditorContainer.classList.contains('markdown-active');
            noteEditorPreview.classList.toggle('hidden', !isActive);
            markdownViewControls.classList.toggle('hidden', !isActive);

            if (isActive) {
                const currentHtml = noteEditorContentEditable.innerHTML;
                noteEditorContentEditable.innerText = turndownService.turndown(currentHtml);
                markdownViewState = 1; 
                applyMarkdownViewState();
                updateMarkdownPreview();
            } else {
                noteEditorContentEditable.innerHTML = noteEditorPreview.innerHTML;
                modalEditorContainer.classList.remove('md-editor-only', 'md-preview-only');
            }
        });

        function applyMarkdownViewState() {
            modalEditorContainer.classList.remove('md-editor-only', 'md-preview-only');
            if (markdownViewState === 0) { // Editor only
                modalEditorContainer.classList.add('md-editor-only');
            } else if (markdownViewState === 2) { // Preview only
                modalEditorContainer.classList.add('md-preview-only');
            }
        }

        mdViewNextBtn.addEventListener('click', () => {
            markdownViewState = (markdownViewState + 1) % 3;
            applyMarkdownViewState();
        });

        mdViewPrevBtn.addEventListener('click', () => {
            markdownViewState = (markdownViewState - 1 + 3) % 3;
            applyMarkdownViewState();
        });

        function updateMarkdownPreview() {
            if (modalEditorContainer.classList.contains('markdown-active')) {
                const markdownText = noteEditorContentEditable.innerText;
                noteEditorPreview.innerHTML = marked.parse(markdownText);
            }
        }

        noteEditorContentEditable.addEventListener('input', () => {
             if (modalEditorContainer.classList.contains('markdown-active')) {
                updateMarkdownPreview();
             }
        });

        noteEditorContentEditable.addEventListener('click', (e) => {
            const target = e.target;

            const link = target.closest('a[href]');
            if (link && link.href) {
                if (!link.classList.contains('internal-link') && !link.classList.contains('internal-link-broken')) {
                   e.preventDefault();
                   window.open(link.href, '_blank', 'noopener,noreferrer');
                   return;
                }
            }

            if (target.classList.contains('checklist-box')) {
                e.preventDefault();
                const li = target.closest('li');
                if (li) {
                    const isCompleted = li.classList.toggle('completed');
                    target.textContent = isCompleted ? 'check_box' : 'check_box_outline_blank';
                }
            }
            if (target.closest('.reorder-handles')) {
                const li = target.closest('li');
                if (!li) return;

                if (target.classList.contains('reorder-up')) {
                    if (li.previousElementSibling) {
                        li.parentElement.insertBefore(li, li.previousElementSibling);
                    }
                } else if (target.classList.contains('reorder-down')) {
                    if (li.nextElementSibling) {
                        li.parentElement.insertBefore(li.nextElementSibling, li);
                    }
                } else if (target.classList.contains('reorder-delete')) {
                    li.remove();
                }
            }
        });
        
        let wikilinkPopup = null;
        let currentWikilinkRange = null;

        const debouncedHandleEditorInput = debounce(handleEditorInput, 200);
        noteEditorContentEditable.addEventListener('input', debouncedHandleEditorInput);
        noteEditorContentEditable.addEventListener('keyup', e => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Escape', 'Enter'].includes(e.key)) {
              handleEditorKeyUp(e);
            }
        });
        
        function getWikilinkQuery(node, offset) {
            let text = node.textContent;
            let start = -1, end = -1;
            
            let tempStart = text.lastIndexOf('[[', offset - 1);
            if (tempStart !== -1) {
                let tempEnd = text.indexOf(']]', tempStart);
                if (tempEnd === -1 || offset <= tempEnd + 2) {
                    start = tempStart;
                    end = offset;
                }
            }
            
            if (start !== -1) {
                return {
                    query: text.substring(start + 2, end),
                    startOffset: start,
                    endOffset: end
                };
            }
            return null;
        }
        
        function handleEditorInput(e) {
          const selection = window.getSelection();
          if (!selection.rangeCount > 0) return;
          
          const range = selection.getRangeAt(0);
          const node = range.startContainer;
          
          if(node.nodeType === Node.TEXT_NODE) {
              const linkData = getWikilinkQuery(node, range.startOffset);

              if (linkData) {
                  currentWikilinkRange = document.createRange();
                  currentWikilinkRange.setStart(node, linkData.startOffset);
                  currentWikilinkRange.setEnd(node, linkData.endOffset);
                  showWikilinkPopup(linkData.query, currentWikilinkRange.getBoundingClientRect());
                  return;
              }
          }
          hideWikilinkPopup();
        }
        
        function handleEditorKeyUp(e) {
            if (!wikilinkPopup) return;
            const items = wikilinkPopup.querySelectorAll('li');
            if (items.length === 0) return;

            let currentIndex = -1;
            items.forEach((item, index) => {
                if (item.classList.contains('selected')) {
                    currentIndex = index;
                }
            });
            
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                let nextIndex = (currentIndex + 1) % items.length;
                if (currentIndex > -1) items[currentIndex].classList.remove('selected');
                items[nextIndex].classList.add('selected');
                items[nextIndex].scrollIntoView({ block: 'nearest' });
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                let prevIndex = currentIndex <= 0 ? items.length - 1 : currentIndex - 1;
                if (currentIndex > -1) items[currentIndex].classList.remove('selected');
                items[prevIndex].classList.add('selected');
                items[prevIndex].scrollIntoView({ block: 'nearest' });
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (currentIndex > -1) {
                    items[currentIndex].click();
                }
            } else if (e.key === 'Escape') {
                e.preventDefault();
                hideWikilinkPopup();
            }
        }

        function showWikilinkPopup(query, rect) {
            if (!wikilinkPopup) {
                wikilinkPopup = document.createElement('div');
                wikilinkPopup.id = 'wikilink-popup';
                document.body.appendChild(wikilinkPopup);
            }
            
            const filteredNotes = [...displayNameMap.values()].filter(note => 
                note.displayName.toLowerCase().includes(query.toLowerCase())
            );
            
            if(filteredNotes.length === 0){
                hideWikilinkPopup();
                return;
            }

            wikilinkPopup.innerHTML = `<ul>${filteredNotes.map(note => `<li data-note-title="${note.displayName}">${note.displayName}</li>`).join('')}</ul>`;
            
            wikilinkPopup.style.left = `${rect.left}px`;
            wikilinkPopup.style.top = `${rect.bottom + window.scrollY}px`;
            
            wikilinkPopup.onclick = (e) => {
                const target = e.target.closest('li');
                if (target) {
                    insertWikilink(target.dataset.noteTitle);
                }
            };
        }

        function hideWikilinkPopup() {
            if (wikilinkPopup) {
                wikilinkPopup.remove();
                wikilinkPopup = null;
                currentWikilinkRange = null;
            }
        }

        function insertWikilink(title) {
            if (currentWikilinkRange) {
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(currentWikilinkRange);
                document.execCommand('insertText', false, `[[${title}]]`);
            }
            hideWikilinkPopup();
        }

        noteEditorContentEditable.addEventListener('keydown', (e) => {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            const range = selection.getRangeAt(0);
            const currentNode = selection.anchorNode;
            const parentElement = currentNode.nodeType === 3 ? currentNode.parentElement : currentNode;
            const currentLi = parentElement.closest('ul.checklist > li');
            const preElement = parentElement.closest('pre');
            
            if (wikilinkPopup && (e.key === 'Enter' || e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
               e.preventDefault();
               return;
            }

            if (e.key === 'Enter') {
                if (selection.rangeCount > 0) {
                    const container = range.commonAncestorContainer;
                    const blockElement = (container.nodeType === 1 ? container : container.parentNode).closest('#note-editor-contenteditable > *');

                    if (blockElement && !blockElement.closest('li, td, th, pre, blockquote')) {
                        const text = blockElement.textContent || '';
                        if (text.trim().startsWith('-')) {
                            if (e.shiftKey) { 
                                return;
                            }
                            e.preventDefault();
                            document.execCommand('insertParagraph');
                            document.execCommand('insertText', false, '- ');
                            return;
                        }
                    }
                }
                if (currentLi) {
                    e.preventDefault();
                    const newLi = document.createElement('li');
                    newLi.innerHTML = `<i class="material-icons checklist-box">check_box_outline_blank</i><div class="checklist-text"><br></div>${reorderHandlesHTML}`;
                    newLi.style.paddingLeft = currentLi.style.paddingLeft;
                    currentLi.after(newLi);
                    const newTextElement = newLi.querySelector('.checklist-text');
                    const newRange = document.createRange();
                    newRange.setStart(newTextElement, 0);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                    return;
                }

                if (preElement) {
                    if (e.shiftKey) {
                        return; 
                    }
                    e.preventDefault();
                    const newP = document.createElement('p');
                    newP.innerHTML = '<br>';
                    preElement.after(newP);
                    const newRange = document.createRange();
                    newRange.setStart(newP, 0);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                    return;
                }
            }
            
            if (e.key === 'Backspace' && currentLi) {
                const textContent = currentNode.textContent;
                const range = selection.getRangeAt(0);
                if (range.startOffset === 0 && range.endOffset === 0 && (textContent === "" || textContent === "\n")) {
                    e.preventDefault();
                    const prevLi = currentLi.previousElementSibling;
                    if (prevLi) {
                        const prevText = prevLi.querySelector('.checklist-text');
                        if (prevText) {
                            const newRange = document.createRange();
                            const sel = window.getSelection();
                            newRange.selectNodeContents(prevText);
                            newRange.collapse(false); 
                            sel.removeAllRanges();
                            sel.addRange(newRange);
                        }
                    }
                    currentLi.remove();
                }
            } else if (e.key === 'Tab' && currentLi) {
                e.preventDefault();
                const INDENT_STEP = 30;
                let currentPadding = parseInt(currentLi.style.paddingLeft, 10) || 0;
                if (e.shiftKey) {
                    currentLi.style.paddingLeft = Math.max(0, currentPadding - INDENT_STEP) + 'px';
                } else {
                    currentLi.style.paddingLeft = (currentPadding + INDENT_STEP) + 'px';
                }
            }
        });
        
          const tableToolbar = document.createElement('div');
          tableToolbar.id = 'table-editing-toolbar';
          tableToolbar.style.cssText = `position: absolute; display: none; z-index: 1100; background-color: var(--bg-secondary); border: 1px solid var(--border-color); box-shadow: var(--shadow-lg); border-radius: 6px; padding: 5px; gap: 4px;`;
                  tableToolbar.innerHTML = `
              <button class="tooltipped" data-position="top" data-tooltip="Añadir fila arriba" data-action="add-row-above"><i class="material-icons" style="font-size:20px;">keyboard_arrow_up</i></button>
              <button class="tooltipped" data-position="top" data-tooltip="Añadir fila abajo" data-action="add-row-below"><i class="material-icons" style="font-size:20px;">keyboard_arrow_down</i></button>
              <button class="tooltipped" data-position="top" data-tooltip="Añadir columna a la izquierda" data-action="add-col-left"><i class="material-icons" style="font-size:20px;">keyboard_arrow_left</i></button>
              <button class="tooltipped" data-position="top" data-tooltip="Añadir columna a la derecha" data-action="add-col-right"><i class="material-icons" style="font-size:20px;">keyboard_arrow_right</i></button>
              <span style="border-left: 1px solid var(--border-color); margin: 2px 4px;"></span>
              <button class="tooltipped" data-position="top" data-tooltip="Eliminar fila" data-action="delete-row"><i class="material-icons" style="font-size:18px; color: var(--danger-color);">remove_circle_outline</i></button>
              <button class="tooltipped" data-position="top" data-tooltip="Eliminar columna" data-action="delete-col"><i class="material-icons" style="font-size:18px; color: var(--danger-color);">delete_sweep</i></button>
          `;
          document.body.appendChild(tableToolbar);
          M.Tooltip.init(tableToolbar.querySelectorAll('.tooltipped'));

          tableToolbar.querySelectorAll('button').forEach(btn => {
              btn.style.cssText += `background: transparent; border: none; cursor: pointer; padding: 4px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; color: var(--text-secondary);`;
              btn.onmouseover = () => { btn.style.backgroundColor = 'var(--bg-tertiary)'; };
              btn.onmouseout = () => { btn.style.backgroundColor = 'transparent'; };
          });

          let activeTableElement = null;

          noteEditorContentEditable.addEventListener('dblclick', (e) => {
              const cell = e.target.closest('td, th');
              if (cell) {
                  activeTableElement = cell;
                  const rect = cell.getBoundingClientRect();
                  tableToolbar.style.display = 'flex';
                  tableToolbar.style.top = `${window.scrollY + rect.top - tableToolbar.offsetHeight - 5}px`;
                  tableToolbar.style.left = `${window.scrollX + rect.left}px`;
              }
          });

          document.addEventListener('click', (e) => {
               if (!e.target.closest('#table-editing-toolbar') && !e.target.closest('td, th')) {
                  tableToolbar.style.display = 'none';
                  activeTableElement = null;
              }
          });


          tableToolbar.addEventListener('mousedown', (e) => e.preventDefault());

          tableToolbar.addEventListener('click', (e) => {
              const button = e.target.closest('button[data-action]');
              if (!button || !activeTableElement) return;

              const action = button.dataset.action;
              const currentCell = activeTableElement;
              const currentRow = currentCell.parentElement;
              const table = currentCell.closest('table');
              const cellIndex = currentCell.cellIndex;

              const createCell = (isHeader) => {
                  const newCell = document.createElement(isHeader ? 'th' : 'td');
                  newCell.innerHTML = isHeader ? 'Encabezado' : '<br>';
                  newCell.style.cssText = `border: 1.5px solid var(--border-color); padding: 8px; background-color: ${isHeader ? 'var(--bg-tertiary)' : 'transparent'};`;
                  return newCell;
              };

              switch (action) {
                  case 'add-row-above':
                      currentRow.parentElement.insertBefore(currentRow.cloneNode(true), currentRow).querySelectorAll('td, th').forEach(c => c.innerHTML = '<br>');
                      break;
                  case 'add-row-below':
                      currentRow.parentElement.insertBefore(currentRow.cloneNode(true), currentRow.nextSibling).querySelectorAll('td, th').forEach(c => c.innerHTML = '<br>');
                      break;
                  case 'add-col-left':
                      table.querySelectorAll('tr').forEach(row => row.insertBefore(createCell(row.parentElement.tagName === 'THEAD'), row.cells[cellIndex]));
                      break;
                  case 'add-col-right':
                      table.querySelectorAll('tr').forEach(row => row.insertBefore(createCell(row.parentElement.tagName === 'THEAD'), row.cells[cellIndex + 1]));
                      break;
                  case 'delete-row':
                      if (table.rows.length > 1) currentRow.remove(); else table.remove();
                      tableToolbar.style.display = 'none'; activeTableElement = null;
                      break;
                  case 'delete-col':
                      if (currentRow.cells.length > 1) table.querySelectorAll('tr').forEach(row => { if (row.cells[cellIndex]) row.cells[cellIndex].remove(); }); else table.remove();
                      tableToolbar.style.display = 'none'; activeTableElement = null;
                      break;
              }
              noteEditorContentEditable.focus();
          });


          addTableOption.addEventListener('click', (e) => {
              e.preventDefault();
              noteEditorContentEditable.focus();
              createTableModal.classList.remove('hidden');
              createTableModalOverlay.classList.remove('hidden');
              var instance = M.Dropdown.getInstance(document.getElementById('more-options-dropdown'));
              if (instance) instance.close();
          });

          function hideCreateTableModal() {
              createTableModal.classList.add('hidden');
              createTableModalOverlay.classList.add('hidden');
          }
          cancelCreateTableBtn.addEventListener('click', hideCreateTableModal);
          createTableModalOverlay.addEventListener('click', hideCreateTableModal);

          confirmCreateTableBtn.addEventListener('click', () => {
              const rows = parseInt(document.getElementById('table-rows-input').value, 10);
              const cols = parseInt(document.getElementById('table-cols-input').value, 10);

              if (isNaN(rows) || isNaN(cols) || rows < 1 || cols < 1) {
                  M.toast({html: 'Introduce números válidos.', classes: 'red'}); return;
              }
              
              let tableHtml = `<table title="Doble clic en una celda para ver opciones de edición" style="width:100%; border-collapse: collapse;"><thead><tr>`;
              for (let i = 0; i < cols; i++) tableHtml += `<th contenteditable="true">Encabezado</th>`;
              tableHtml += '</tr></thead><tbody>';
              for (let i = 0; i < rows - 1; i++) {
                  tableHtml += '<tr>';
                  for (let j = 0; j < cols; j++) tableHtml += `<td contenteditable="true"><br></td>`;
                  tableHtml += '</tr>';
              }
              tableHtml += '</tbody></table><p><br></p>';

              noteEditorContentEditable.focus();
              document.execCommand('insertHTML', false, tableHtml);
              hideCreateTableModal();
          });
          
          function hideHistoryModal() {
              historyModal.classList.add('hidden');
              historyModalOverlay.classList.add('hidden');
              document.body.classList.remove('modal-active');
          }
          
          function hideHistoryPreviewModal() {
              historyPreviewModal.classList.add('hidden');
              historyPreviewModalOverlay.classList.add('hidden');
              document.body.classList.remove('modal-active');
          }

          closeHistoryModalBtn.addEventListener('click', hideHistoryModal);
          historyModalOverlay.addEventListener('click', hideHistoryModal);
          closeHistoryPreviewModalBtn.addEventListener('click', hideHistoryPreviewModal);
          historyPreviewModalOverlay.addEventListener('click', hideHistoryPreviewModal);

          async function openHistoryModalForNote() {
              if (!currentEditingNoteName) return;
              const noteData = findNoteDataByDecodedName(currentEditingNoteName);
              if (!noteData) return;
              
              historyModal.classList.remove('hidden');
              historyModalOverlay.classList.remove('hidden');
              document.body.classList.add('modal-active');
              historyContainer.innerHTML = "Cargando historial...";

              const versionsDir = webdavNotesUrl + ".versiones/";
              try {
                  const response = await fetch(versionsDir, { method: 'PROPFIND', headers: { 'Depth': '1' } });
                  if (response.status === 404) {
                       historyContainer.innerHTML = "No se encontraron versiones para esta nota.";
                       return;
                  }
                  if (!response.ok) throw new Error(`Directorio de versiones no encontrado o inaccesible.`);
                  
                  const xmlText = await response.text();
                  const xml = new DOMParser().parseFromString(xmlText, "text/xml");
                  const responses = xml.getElementsByTagName("D:response");
                  let versions = [];
                  for(let r of responses) {
                      const href = r.getElementsByTagName("D:href")[0].textContent;
                      const fileName = decodeURIComponent(href.split('/').pop());
                      if (fileName.endsWith(`-${noteData.name}.html`)) {
                          versions.push(fileName);
                      }
                  }
                  
                  versions.sort().reverse(); 
                  
                  if (versions.length === 0) {
                      historyContainer.innerHTML = "No se encontraron versiones para esta nota.";
                      return;
                  }
                  
                  const ul = document.createElement('ul');
                  versions.forEach(fileName => {
                      const li = document.createElement('li');
                      const [timestamp] = fileName.split('-');
                      const date = new Date(`${timestamp.substring(0,4)}-${timestamp.substring(4,6)}-${timestamp.substring(6,8)}T${timestamp.substring(9,11)}:${timestamp.substring(11,13)}:${timestamp.substring(13,15)}`);
                      
                      const dateSpan = document.createElement('span');
                      dateSpan.className = 'version-date';
                      dateSpan.textContent = date.toLocaleString('es-ES');
                      
                      const viewBtn = document.createElement('a');
                      viewBtn.href = '#!';
                      viewBtn.className = 'btn-flat waves-effect';
                      viewBtn.textContent = 'Ver';
                      viewBtn.dataset.backupFile = fileName;
                      viewBtn.dataset.action = 'view-version';
                      
                      const restoreBtn = document.createElement('a');
                      restoreBtn.href = '#!';
                      restoreBtn.className = 'btn-flat waves-effect';
                      restoreBtn.textContent = 'Restaurar';
                      restoreBtn.dataset.backupFile = fileName;
                      restoreBtn.dataset.action = 'restore-version';
                      
                      li.appendChild(dateSpan);
                      li.appendChild(viewBtn);
                      li.appendChild(restoreBtn);
                      ul.appendChild(li);
                  });
                  historyContainer.innerHTML = '';
                  historyContainer.appendChild(ul);

              } catch(e) {
                  historyContainer.innerHTML = `Error: ${e.message}`;
              }
          }
          
          historyContainer.addEventListener('click', (e) => {
              const action = e.target.dataset.action;
              const backupFile = e.target.dataset.backupFile;

              if (action === 'restore-version') {
                  if (confirm(`¿Restaurar la versión "${backupFile}"? Esto sobreescribirá la nota actual.`)) {
                      restoreNoteVersion(backupFile);
                  }
              } else if (action === 'view-version') {
                  showVersionPreview(backupFile);
              }
          });

          async function showVersionPreview(backupFileName) {
              historyPreviewModal.classList.remove('hidden');
              historyPreviewModalOverlay.classList.remove('hidden');
              historyPreviewContent.innerHTML = 'Cargando...';

              const backupUrl = webdavNotesUrl + ".versiones/" + encodeURIComponent(backupFileName);
              try {
                  const response = await fetch(backupUrl);
                  if (!response.ok) throw new Error('No se pudo leer el archivo de respaldo.');
                  const backupContent = await response.text();
                  historyPreviewContent.innerHTML = backupContent;
                  addCopyButtonsToCodeBlocks(historyPreviewContent);
              } catch (error) {
                  historyPreviewContent.innerHTML = `<p style="color:red">Error al cargar la vista previa: ${error.message}</p>`;
              }
          }
          
          async function restoreNoteVersion(backupFileName) {
               const noteData = findNoteDataByDecodedName(currentEditingNoteName);
               if (!noteData) {
                   M.toast({html: 'No se pudo encontrar la nota original.', classes: 'red'});
                   return;
               }
               M.toast({html: 'Restaurando...', displayLength: 60000});
               showProgress();

               const backupUrl = webdavNotesUrl + ".versiones/" + encodeURIComponent(backupFileName);
               const originalUrl = noteData.path;

               try {
                  const backupResponse = await fetch(backupUrl);
                  if (!backupResponse.ok) throw new Error('No se pudo leer el archivo de respaldo.');
                  const backupContent = await backupResponse.text();
                  
                  await saveBackupCopyForNote(noteData);

                  const restoreResponse = await fetch(originalUrl, {
                      method: 'PUT',
                      headers: { 'Content-Type': 'text/html; charset=UTF-8' },
                      body: backupContent
                  });
                  if (!restoreResponse.ok && !/20[0-9]/.test(restoreResponse.status)) throw new Error('Error al sobreescribir la nota actual.');
                  
                  M.Toast.dismissAll();
                  M.toast({html: 'Nota restaurada con éxito.', classes: 'green'});
                  hideHistoryModal();
                  hideEditorView();
                  fetchNotesAndDisplayCards();

               } catch (error) {
                   M.Toast.dismissAll();
                   M.toast({html: `Error en la restauración: ${error.message}`, classes: 'red'});
               } finally {
                  hideProgress();
               }
          }

          function cleanNoteFormatting(htmlString) {
              if (!htmlString) return '';
              if (htmlString.startsWith(ENCRYPTION_PREFIX)) {
                  return htmlString;
              }
              const doc = contentParser.parseFromString(htmlString, 'text/html');
              
              doc.body.querySelectorAll('*').forEach(el => {
                  el.removeAttribute('style');
                  el.removeAttribute('bgcolor');
                  el.removeAttribute('color');
                  el.removeAttribute('face');
                  el.removeAttribute('size');
              });
              
              doc.body.querySelectorAll('font').forEach(fontTag => {
                  const parent = fontTag.parentNode;
                  while(fontTag.firstChild) {
                      parent.insertBefore(fontTag.firstChild, fontTag);
                  }
                  parent.removeChild(fontTag);
              });

              return doc.body.innerHTML;
          }

          async function handleCleanFormat(noteData, cardElement) {
              if (!noteData) return;
              if (!confirm("Esto eliminará todos los colores y estilos del contenido, dejando solo la estructura básica. ¿Continuar?")) {
                  return;
              }

              M.toast({html: 'Limpiando formato...'});
              showProgress();
              try {
                  let originalContent = noteData.content;
                  
                  if (!originalContent) {
                      const response = await fetch(noteData.path);
                      if (!response.ok) throw new Error('No se pudo cargar la nota para limpiarla.');
                      originalContent = await response.text();
                  }

                  const cleanedBodyContent = cleanNoteFormatting(originalContent);
                  const fullHtmlToSave = `<!DOCTYPE html><html lang="es"><head><meta charset="UTF-8"><title>${noteData.displayName}</title></head><body>${cleanedBodyContent}</body></html>`;

                  const saveResponse = await fetch(noteData.path, {
                      method: 'PUT',
                      headers: { 'Content-Type': 'text/html; charset=UTF-8' },
                      body: fullHtmlToSave
                  });

                  if (!saveResponse.ok && !/20[0-9]/.test(saveResponse.status)) {
                      throw new Error(`Error al guardar: ${saveResponse.status}`);
                  }
                  
                  noteData.content = cleanedBodyContent;
                  if (cardElement) {
                      const contentDiv = cardElement.querySelector('.note-card-content');
                      if (contentDiv) contentDiv.innerHTML = processWikilinks(cleanedBodyContent);
                  }
                  M.toast({html: 'Formato limpiado y nota guardada.', classes: 'green'});

              } catch (error) {
                  M.toast({html: `Error al limpiar formato: ${error.message}`, classes: 'red'});
              } finally {
                  hideProgress();
              }
          }
        
        
        // --- Sidebar Tag Filter ---
        const tagFilterInput = document.getElementById('tag-filter-input');
        tagFilterInput.addEventListener('input', () => {
            const filterText = tagFilterInput.value.toLowerCase();
            document.querySelectorAll('#tags-list li').forEach(li => {
                const tagText = li.textContent.toLowerCase();
                li.style.display = tagText.includes(filterText) ? '' : 'none';
            });
        });
        
        // --- View Toggle Initialization ---
        const savedViewMode = localStorage.getItem('wdnotes-view-mode') || 'grid';
        const urlViewMode = urlParams.get('modo');

        if (urlViewMode === 'lista' || (!urlViewMode && savedViewMode === 'list')) {
          notesGridContainer.classList.add('list-view');
          toggleViewBtn.textContent = 'Vista de Rejilla';
        } else {
          notesGridContainer.classList.remove('list-view');
          toggleViewBtn.textContent = 'Vista de Lista';
        }

        toggleViewBtn.addEventListener('click', (e) => {
          e.preventDefault();
          const isListView = notesGridContainer.classList.toggle('list-view');
          const url = new URL(window.location);
          if (isListView) {
              toggleViewBtn.textContent = 'Vista de Rejilla';
              localStorage.setItem('wdnotes-view-mode', 'list');
              url.searchParams.set('modo', 'lista');
          } else {
              toggleViewBtn.textContent = 'Vista de Lista';
              localStorage.setItem('wdnotes-view-mode', 'grid');
              url.searchParams.delete('modo');
          }
          history.pushState({}, '', url);
          displaySortedNotes(Array.from(allNotesDataMap.values()));
        });
        
        // --- Wikilink Global Click Handler ---
        document.body.addEventListener('click', e => {
            const link = e.target.closest('a.internal-link');
            if (link) {
                e.preventDefault();
                const noteNameToOpen = link.dataset.noteName;
                if (noteNameToOpen) {
                    showEditorView(noteNameToOpen);
                }
            }
            const brokenLink = e.target.closest('a.internal-link-broken');
            if(brokenLink){
                e.preventDefault();
                const noteTitleToCreate = brokenLink.textContent;
                if(confirm(`La nota "${noteTitleToCreate}" no existe. ¿Quieres crearla?`)){
                     addNewNote(noteTitleToCreate);
                }
            }
        });
        
        // --- Attachments Logic ---
        addFileOption.addEventListener('click', (e) => {
            e.preventDefault();
            fileAttachmentInput.click();
            var instance = M.Dropdown.getInstance(document.getElementById('more-options-dropdown'));
            if (instance) instance.close();
        });

        fileAttachmentInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const attachmentsDir = webdavNotesUrl + '.files/';
            const sanitizedFilename = sanitizeForFilenamePart(file.name);
            const filePath = attachmentsDir + encodeURIComponent(sanitizedFilename);
            
            M.toast({html: `Subiendo ${sanitizedFilename}...`});
            showProgress();

            try {
                await fetch(attachmentsDir, { method: 'MKCOL' });
            } catch (error) {}

            try {
                const response = await fetch(filePath, { method: 'PUT', body: file });
                if (!response.ok && !/20[0-9]/.test(response.status)) {
                    throw new Error(`Error en la subida: ${response.statusText}`);
                }

                let attachmentsContainer = noteEditorContentEditable.querySelector('.note-attachments-container');
                if (!attachmentsContainer) {
                    attachmentsContainer = document.createElement('div');
                    attachmentsContainer.className = 'note-attachments-container';
                    noteEditorContentEditable.appendChild(document.createElement('hr'));
                    noteEditorContentEditable.appendChild(attachmentsContainer);
                }

                const attachmentItem = document.createElement('div');
                attachmentItem.className = 'attachment-item';
                attachmentItem.innerHTML = `<i class="material-icons">attach_file</i> <a href=".files/${encodeURIComponent(sanitizedFilename)}" target="_blank" rel="noopener noreferrer">${sanitizedFilename}</a>`;
                attachmentsContainer.appendChild(attachmentItem);

                M.toast({html: 'Archivo adjuntado.', classes: 'green'});

            } catch (error) {
                M.toast({html: `Error al adjuntar archivo: ${error.message}`, classes: 'red'});
            } finally {
              hideProgress();
            }

            fileAttachmentInput.value = '';
        });

        // --- Camera and Image Resize Logic ---
        addCameraOption.addEventListener('click', (e) => {
          e.preventDefault();
          cameraInput.click();
          M.Dropdown.getInstance(document.getElementById('more-options-dropdown')).close();
        });

        cameraInput.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) {
              resizeAndInsertImage(file);
          }
          cameraInput.value = '';
        });

         function resizeAndInsertImage(file) {
          const MAX_WIDTH = 800;
          const reader = new FileReader();

          reader.onload = (e) => {
              const img = new Image();
              img.onload = () => {
                  const canvas = document.createElement('canvas');
                  let width = img.width;
                  let height = img.height;

                  if (width > MAX_WIDTH) {
                      height *= MAX_WIDTH / width;
                      width = MAX_WIDTH;
                  }

                  canvas.width = width;
                  canvas.height = height;
                  const ctx = canvas.getContext('2d');
                  ctx.drawImage(img, 0, 0, width, height);

                  const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                  noteEditorContentEditable.focus();
                  document.execCommand('insertHTML', false, `<img src="${dataUrl}" alt="Imagen insertada" style="width:100%;">`);
                  M.toast({html: 'Imagen insertada.', classes: 'green'});
              };
              img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        }

        const imageResizeControls = document.getElementById('image-resize-controls');
        const imageSizeSlider = document.getElementById('image-size-slider');
        let currentlyEditingImage = null;

        noteEditorContentEditable.addEventListener('click', (e) => {
          if (e.target.tagName === 'IMG') {
              e.preventDefault();
              currentlyEditingImage = e.target;
              
              const currentWidth = parseInt(currentlyEditingImage.style.width, 10) || 100;
              imageSizeSlider.value = currentWidth;
              
              const imgRect = currentlyEditingImage.getBoundingClientRect();
              imageResizeControls.style.display = 'flex';
              imageResizeControls.style.top = `${window.scrollY + imgRect.top - imageResizeControls.offsetHeight - 5}px`;
              imageResizeControls.style.left = `${window.scrollX + imgRect.left}px`;
          }
        });
        
        imageSizeSlider.addEventListener('input', () => {
          if (currentlyEditingImage) {
              currentlyEditingImage.style.width = `${imageSizeSlider.value}%`;
          }
        });
        
        document.body.addEventListener('click', (e) => {
          if (currentlyEditingImage && !imageResizeControls.contains(e.target) && e.target !== currentlyEditingImage) {
              imageResizeControls.style.display = 'none';
              currentlyEditingImage = null;
          }
        }, true);


        await fetchNotesAndDisplayCards();
        setActiveSidebarItem(allNotesBtn);

        const noteNameToOpen = urlParams.get('nota');
        if (noteNameToOpen && findNoteDataByDecodedName(noteNameToOpen)) {
            showEditorView(noteNameToOpen);
        }

        // --- AI MODAL FUNCTIONS ---
        
        let providersData = {};
        let modelCache = {};
        let savedProviderFromFile = null;
        let savedModelFromFile = null;

        function openDictationModal() {
            const title = modalTitleInput.value;
            const content = noteEditorContentEditable.innerHTML;
            const fullNoteText = title + '\n\n' + htmlToStructuredText(unprocessWikilinks(content));
            
            document.getElementById('dictation-editContent').value = fullNoteText;
            document.getElementById('dictation-correctionContent').value = '';
            document.getElementById('dictationModal').style.display = 'block';
            initializeAIModal({type: 'dictation'});
        }

        function openImproveModal() {
            const title = modalTitleInput.value;
            const content = noteEditorContentEditable.innerHTML;
            const fullNoteText = title + '\n\n' + htmlToStructuredText(unprocessWikilinks(content));
            
            document.getElementById('improve-originalContent').value = fullNoteText;
            document.getElementById('improve-correctedContent').value = '';
            document.getElementById('improveModal').style.display = 'block';
            initializeAIModal({type: 'improve'});
        }

        function saveNoteFromDictationModal() {
            const newContentText = document.getElementById('dictation-editContent').value;
            const lines = newContentText.split('\n');
            const newTitle = lines.shift();
            const newContent = lines.join('\n');
            
            modalTitleInput.value = newTitle;
            noteEditorContentEditable.innerHTML = processWikilinks(textToHtml(newContent));
            
            document.getElementById('dictationModal').style.display = 'none';
            M.toast({html: 'Contenido actualizado. Cierra la nota para guardar.'});
        }

        function saveNoteFromImproveModal() {
            const newContentText = document.getElementById('improve-correctedContent').value;
            
            modalTitleInput.value = modalTitleInput.value; 
            noteEditorContentEditable.innerHTML = newContentText;
            
            document.getElementById('improveModal').style.display = 'none';
            M.toast({html: 'Contenido actualizado. Cierra la nota para guardar.'});
        }

        async function openLLMChangePopup() {
            try {
                M.toast({html: '⚙️ Abriendo selector de modelo...'});
                await showLLMSelector();
            } catch (error) {
                M.toast({html: `❌ Error: ${error.message}`, classes: 'red'});
            }
        }
        
        async function loadProviders() {
            try {
                const response = await fetch(PROVIDERS_CONFIG_DAV_PATH, { cache: 'no-store' });
                if (!response.ok) throw new Error(`No se pudo cargar config.txt`);
                
                const lines = (await response.text()).trim().split('\n').filter(line => line.trim() && !line.trim().startsWith('#'));
                providersData = {};
                
                lines.forEach(line => {
                    const parts = line.split(',');
                    if (parts.length >= 2) {
                        const displayName = parts[0].trim();
                        let rawApiUrl = parts[1].trim();
                        let apiKey = parts[2]?.trim() || null;
                        if (apiKey === "") apiKey = null;

                        let authUser = null, authPass = null, cleanApiUrl = rawApiUrl;
                        try {
                            const urlObj = new URL(rawApiUrl);
                            if (urlObj.username) {
                                authUser = decodeURIComponent(urlObj.username);
                                authPass = decodeURIComponent(urlObj.password);
                                cleanApiUrl = `${urlObj.protocol}//${urlObj.host}${urlObj.pathname}${urlObj.search}${urlObj.hash}`;
                            }
                        } catch (e) {}

                        if (displayName && cleanApiUrl) {
                            providersData[displayName] = { url: cleanApiUrl, key: apiKey, authUser: authUser, authPass: authPass };
                        }
                    }
                });
            } catch (error) {
                console.error("Error loading providers:", error);
                providersData = {};
            }
        }
    
        async function loadModelsForCurrentProvider(providerName, providerConfig) {
            const { url, key: token, authUser, authPass } = providerConfig;
            const isGemini = url.includes("generativelanguage.googleapis.com");
            const modelsUrl = isGemini 
              ? `https://generativelanguage.googleapis.com/v1beta/models?key=${token}` 
              : `${url.replace(/\/$/, '')}/models`;
            const fetchHeaders = {};

            if (!isGemini) {
                if (authUser && authPass) {
                    fetchHeaders['Authorization'] = `Basic ${btoa(`${authUser}:${authPass}`)}`;
                } else if (token) {
                    fetchHeaders['Authorization'] = `Bearer ${token}`;
                }
            }

            try {
                const response = await fetch(modelsUrl, { method: 'GET', headers: fetchHeaders });
                if (!response.ok) {
                    let errorMsg = `HTTP ${response.statusText}`;
                    try { errorMsg = (await response.json()).error?.message || errorMsg; } catch (e) {}
                    throw new Error(`Failed to get models for ${providerName}: ${errorMsg}`);
                }
                
                const data = await response.json();
                let modelList = (data?.data && Array.isArray(data.data)) ? data.data : (data?.models && Array.isArray(data.models)) ? data.models : (Array.isArray(data) ? data : []);
                
                return modelList
                    .map(m => isGemini ? (m.name ? m.name.split('/').pop() : m.id) : m.id)
                    .filter(Boolean)
                    .sort((a,b) => a.localeCompare(b));
            } catch(error) {
                console.error("Error in loadModelsForCurrentProvider:", error);
                throw error;
            }
        }

        async function showLLMSelector() {
            const llmSelectorOverlay = document.getElementById('llmSelectorOverlay');
            const providerSelector = document.getElementById('llmProviderSelect');
            const modelSelector = document.getElementById('llmModelSelect');
            const saveButton = document.getElementById('llmSaveButton');
            const closeButton = document.getElementById('llmSelectorClose');
            
            llmSelectorOverlay.classList.add('show');
            
            providerSelector.innerHTML = '<option value="">Cargando...</option>';
            modelSelector.innerHTML = '<option value="">Selecciona proveedor</option>';
            modelSelector.disabled = true;
            saveButton.disabled = true;

            await loadProviders();
            await loadLastModelSelectionFromFile();
            
            providerSelector.innerHTML = '<option value="">Selecciona proveedor...</option>';
            if (Object.keys(providersData).length > 0) {
                Object.keys(providersData).sort().forEach(name => {
                    const option = document.createElement('option');
                    option.value = option.textContent = name;
                    providerSelector.appendChild(option);
                });
            } else {
                providerSelector.innerHTML = '<option value="">No hay proveedores</option>';
            }

            const handleProviderChange = async () => {
                const selectedProviderName = providerSelector.value;
                modelSelector.innerHTML = '<option value="">Cargando modelos...</option>';
                modelSelector.disabled = true;
                saveButton.disabled = true;

                if (selectedProviderName && providersData[selectedProviderName]) {
                    try {
                        const models = await loadModelsForCurrentProvider(selectedProviderName, providersData[selectedProviderName]);
                        modelSelector.innerHTML = '<option value="">Selecciona modelo...</option>';
                        if (models.length > 0) {
                            models.forEach(modelId => {
                                const option = document.createElement('option');
                                option.value = option.textContent = modelId;
                                modelSelector.appendChild(option);
                            });
                            modelSelector.disabled = false;
                            saveButton.disabled = false;
                            if (selectedProviderName === savedProviderFromFile && savedModelFromFile) {
                                modelSelector.value = savedModelFromFile;
                            }
                        } else {
                            modelSelector.innerHTML = '<option value="">No hay modelos</option>';
                        }
                    } catch (error) {
                        modelSelector.innerHTML = '<option value="">Error al cargar</option>';
                        M.toast({html: `❌ ${error.message}`, classes: 'red'});
                    }
                } else {
                    modelSelector.innerHTML = '<option value="">Selecciona proveedor</option>';
                }
            };
            
            providerSelector.addEventListener('change', handleProviderChange);

            if (savedProviderFromFile && providersData[savedProviderFromFile]) {
                providerSelector.value = savedProviderFromFile;
                await handleProviderChange();
            }
            
            const cleanupAndClose = () => {
                llmSelectorOverlay.classList.remove('show');
            };

            const onSave = async () => {
                const selection = { provider: providerSelector.value, model: modelSelector.value };
                if (selection.provider && selection.model) {
                    await saveModelSelectionToFile(selection.provider, selection.model);
                    cleanupAndClose();
                } else {
                    M.toast({html: 'ℹ️ Debes seleccionar un proveedor y un modelo.'});
                }
            };

            const onClose = cleanupAndClose;
            
            saveButton.onclick = onSave;
            closeButton.onclick = onClose;
            llmSelectorOverlay.onclick = (e) => { if(e.target === llmSelectorOverlay) onClose(); };
        }

        async function initializeAIModal(config) {
            const { type, prompt } = config;
            const modalId = `${type}Modal`;
            const mainContentId = type === 'improve' ? 'improve-correctedContent' : 'dictation-correctionContent';
            const originalContentId = 'improve-originalContent';
            
            const mainContent = document.getElementById(mainContentId);
            const saveButton = document.getElementById(`${type}-saveButton`);
            const closeButton = document.getElementById(`${type}-closeButton`);
            const correctButton = document.getElementById(`${type}-correctButton`);
            const readAloudButton = document.getElementById(`${type}-readAloudButton`);
            const copyButton = document.getElementById(`${type}-copyButton`);
            const providerSelector = document.getElementById(`${type}-providerSelector`);
            const modelSelector = document.getElementById(`${type}-modelSelector`);
            const saveModelButton = document.getElementById(`${type}-saveModelButton`);
            
            const saveHandler = type === 'improve' ? saveNoteFromImproveModal : saveNoteFromDictationModal;
            saveButton.addEventListener("click", saveHandler);

            closeButton.addEventListener('click', () => {
                speechSynthesis.cancel();
                document.getElementById(modalId).style.display = 'none';
            });
            correctButton.addEventListener("click", executeAIAction);
            readAloudButton.addEventListener("click", function() {
                toggleReadAloud(mainContent.value, this);
            });
            copyButton.addEventListener("click", () => {
                navigator.clipboard.writeText(mainContent.value).then(() => M.toast({html: 'Copiado'}));
            });

            if (type === 'dictation') {
                const DICTADO_URL = "/dav/Notas/org/dictado.txt";
                const editContent = document.getElementById('dictation-editContent');
                document.getElementById("dictation-updateButton").addEventListener("click", () => {
                    fetch(DICTADO_URL)
                        .then(response => response.ok ? response.text() : '')
                        .then(data => { mainContent.value = data; })
                        .catch(error => M.toast({html: `Error: ${error.message}`, classes: 'red'}));
                });
                document.getElementById("dictation-appendButton").addEventListener("click", () => {
                    editContent.value += "\n" + mainContent.value;
                });
                document.getElementById("dictation-cleanButton").addEventListener("click", () => { mainContent.value = ""; });
            }

            function toggleReadAloud(text, buttonElement) {
                if (!window.speechSynthesis) { M.toast({html: 'Tu navegador no soporta la lectura en voz alta.', classes: 'orange'}); return; }
                if (speechSynthesis.speaking) {
                    speechSynthesis.cancel();
                    buttonElement.innerHTML = '<i class="fas fa-volume-high"></i> Leer';
                    return;
                }
                if (text.trim() === '') return;
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'es-ES';
                utterance.onstart = () => { buttonElement.innerHTML = '<i class="fas fa-stop"></i> Detener'; };
                utterance.onend = () => { buttonElement.innerHTML = '<i class="fas fa-volume-high"></i> Leer'; };
                speechSynthesis.speak(utterance);
            }

            async function executeAIAction() {
                const textToProcess = type === 'improve' ? document.getElementById(originalContentId).value.trim() : mainContent.value.trim();
                if (!textToProcess) { M.toast({html: "No hay contenido para procesar.", classes: 'orange'}); return; }
                const provider = providerSelector.value;
                const model = modelSelector.value;
                if (!provider || !model) { M.toast({html: "Selecciona un proveedor y un modelo de IA.", classes: 'orange'}); return; }
                
                correctButton.disabled = true;
                correctButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Procesando...';
                try {
                    const providerConfig = { ...providersData[provider], provider, model };
                    const resultText = await callAI(prompt, textToProcess, providerConfig);
                    mainContent.value = resultText.trim();
                } catch (error) {
                    M.toast({html: '❌ Error con la IA: ' + error.message, classes: 'red'});
                } finally {
                    correctButton.disabled = false;
                    correctButton.innerHTML = `<i class="fas fa-wand-magic-sparkles"></i> ${type === 'improve' ? 'Mejorar con IA' : 'Corregir con IA'}`;
                }
            }
            
            
            await loadProviders();
            await loadLastModelSelectionFromFile();
            
            providerSelector.innerHTML = '<option value="">Selecciona proveedor...</option>';
            Object.keys(providersData).forEach(name => {
                const option = document.createElement("option");
                option.value = option.textContent = name;
                providerSelector.appendChild(option);
            });

            if (savedProviderFromFile && providersData[savedProviderFromFile]) {
                providerSelector.value = savedProviderFromFile;
            }

            const updateModels = async () => {
                const providerName = providerSelector.value;
                modelSelector.innerHTML = '<option value="">Cargando...</option>';
                modelSelector.disabled = true;
                if (providerName && providersData[providerName]) {
                    try {
                        const models = await loadModelsForCurrentProvider(providerName, providersData[providerName]);
                        modelSelector.innerHTML = '<option value="">Selecciona modelo...</option>';
                        models.forEach(modelId => {
                            const option = document.createElement('option');
                            option.value = option.textContent = modelId;
                            modelSelector.appendChild(option);
                        });
                         if (providerName === savedProviderFromFile && savedModelFromFile) {
                            modelSelector.value = savedModelFromFile;
                        }
                        modelSelector.disabled = false;
                    } catch (e) {
                         modelSelector.innerHTML = '<option value="">Error al cargar</option>';
                         M.toast({html: `❌ ${e.message}`, classes: 'red'});
                    }
                } else {
                    modelSelector.innerHTML = '<option value="">Selecciona proveedor</option>';
                }
            };
            
            providerSelector.onchange = updateModels;
            
            if(providerSelector.value) {
               await updateModels();
            }

            saveModelButton.onclick = async () => {
                const provider = providerSelector.value;
                const model = modelSelector.value;
                if(provider && model) {
                    await saveModelSelectionToFile(provider, model);
                    M.toast({html: `✅ Preferencia guardada`, classes: 'green'});
                } else {
                    M.toast({html: `ℹ️ Selecciona un proveedor y modelo primero.`});
                }
            };

            async function callAI(systemPrompt, userPrompt, providerConfig) {
                const { provider: providerName, model, url, key: token, authUser, authPass } = providerConfig;
                let apiUrl, requestBody, fetchHeaders = { 'Content-Type': 'application/json' };
                let responseText;
                
                const messages = [{ role: "system", content: systemPrompt }, { role: "user", content: userPrompt }];

                if (url.includes("generativelanguage.googleapis.com")) {
                    apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${token}`;
                    
                    const contents = messages.filter(msg => msg.role !== 'system').map(msg => ({
                        role: msg.role === 'assistant' ? 'model' : 'user',
                        parts: [{ text: msg.content }]
                    }));

                    requestBody = { contents: contents };
                    const systemInstruction = messages.find(msg => msg.role === 'system');
                    if (systemInstruction) {
                        requestBody.system_instruction = { parts: [{ text: systemInstruction.content }] };
                    }
                } else { 
                    apiUrl = url.replace(/\/$/, '') + '/chat/completions';
                    if (authUser && authPass) {
                        fetchHeaders['Authorization'] = `Basic ${btoa(`${authUser}:${authPass}`)}`;
                    } else if (token) {
                        fetchHeaders['Authorization'] = `Bearer ${token}`;
                    }
                    requestBody = { model: model, messages: messages };
                }

                const response = await fetch(apiUrl, { method: 'POST', headers: fetchHeaders, body: JSON.stringify(requestBody) });
                const responseData = await response.json();
                if (!response.ok) {
                    const errorDetail = responseData.error?.message || JSON.stringify(responseData.error) || response.statusText;
                    throw new Error(`Error API (${providerName} - ${response.status}): ${errorDetail}`);
                }
                
                if (url.includes("generativelanguage.googleapis.com")) {
                    responseText = responseData?.candidates?.[0]?.content?.parts?.[0]?.text;
                } else { 
                    responseText = responseData.choices?.[0]?.message?.content;
                }

                if (!responseText) throw new Error("La respuesta de la IA no contenía texto válido.");
                return responseText;
            }
          }
        
      async function loadLastModelSelectionFromFile() {
          try {
              const response = await fetch(LLM_SELECTION_URL, { cache: 'no-store' });
              if (response.ok) {
                  const text = await response.text();
                  const [provider, model] = text.trim().split(CSV_SEPARATOR);
                  savedProviderFromFile = provider || null;
                  savedModelFromFile = model || null;
              }
          } catch (err) {
              console.warn("No se pudo cargar el archivo de selección de modelo.", err);
          }
      }

      async function saveModelSelectionToFile(provider, model) {
          if (!provider || !model) return;
          const lineToSave = `${provider}${CSV_SEPARATOR}${model}`;
          try {
              await fetch(LLM_SELECTION_URL, { method: 'PUT', headers: { 'Content-Type': 'text/plain;charset=UTF-8' }, body: lineToSave });
              savedProviderFromFile = provider;
              savedModelFromFile = model;
          } catch (err) { console.error("Error al guardar la selección de modelo:", err); }
      }
        
        initializeAIModal({
            type: 'dictation',
            prompt: "Eres un asistente de redacción. Tu objetivo es convertir los inputs dictados por voz en textos correctos a nivel de estilo, gramatical y ortográfico. Los mensajes que recibirás son dictados por voz, por lo que es posible que no sean suficientemente concisos, ni utilicen el vocabulario correcto, además que pueden incluir expresiones redundantes o inconexas. Tu objetivo es reescribir todos los mensajes de un modo conciso y concreto, respetando el formato del texto, sin transformar NADA del significado del contenido dictado, pero adaptándolo para que sea bien estructurado y comprensible. Siempre opta por la versión que conserve el mayor grado de información y fidelidad respecto el texto dictado en todos los aspectos posibles. Es muy importante que te limites a escribir SOLO la nueva versión del texto sin añadir ninguna explicación más. Piénsatelo dos veces"
        });

        initializeAIModal({
            type: 'improve',
            prompt: "Eres un asistente experto en redacción y formato HTML. Tu tarea es mejorar el siguiente texto. El texto de entrada es texto plano extraído de una nota. Debes reescribirlo para que sea más claro, conciso y profesional, corrigiendo cualquier error gramatical u ortográfico. Además, debes aplicar formato HTML apropiado para un editor de notas. Utiliza etiquetas como `<h1>`, `<h2>`, `<h3>` para los títulos, `<b>` para negritas, `<i>` para cursivas, `<ul>` y `<ol>` para listas, y `<p>` para los párrafos. No incluyas `<html>`, `<head>`, o `<body>`. La respuesta debe ser únicamente el contenido HTML mejorado para ser insertado dentro de un `<div>` editable, sin explicaciones adicionales. El texto a mejorar es:"
        });

        // --- YouTube Embed Logic ---
        async function handlePaste(e) {
            const pastedText = (e.clipboardData || window.clipboardData).getData('text');
            const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:m\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/shorts\/)([A-Za-z0-9_-]{11})/;
            const match = pastedText.match(youtubeRegex);

            if (match && match[1]) {
                e.preventDefault();
                const videoId = match[1];
                
                try {
                    const oembedUrl = `https://www.youtube.com/oembed?url=${encodeURIComponent('https://www.youtube.com/watch?v=' + videoId)}&format=json`;
                    const response = await fetch(oembedUrl);
                    if (!response.ok) throw new Error('oEmbed request failed');
                    const data = await response.json();

                    const embedHtml = `
                        <div class="embed-card">
                            <iframe src="https://www.youtube.com/embed/${videoId}?rel=0&modestbranding=1" loading="lazy" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; fullscreen"></iframe>
                            <div class="embed-meta">
                                <div class="embed-title">${data.title}</div>
                                <div class="embed-author">${data.author_name}</div>
                            </div>
                        </div><p><br></p>`;

                    document.execCommand('insertHTML', false, embedHtml);
                } catch (error) {
                    console.error('Failed to get YouTube oEmbed data:', error);
                    document.execCommand('insertText', false, pastedText);
                }
            }
        }
        noteEditorContentEditable.addEventListener('paste', handlePaste);


        // --- Encryption Logic ---
        function showEncryptModal(mode) {
            encryptModalTitle.textContent = mode === 'encrypt' ? 'Cifrar Nota' : 'Descifrar Nota';
            encryptModal.dataset.mode = mode;
            encryptModal.classList.remove('hidden');
            encryptModalOverlay.classList.remove('hidden');
            document.body.classList.add('modal-active');
            encryptPasswordInput.focus();
            encryptPasswordInput.value = '';
        }

        function hideEncryptModal() {
            encryptModal.classList.add('hidden');
            encryptModalOverlay.classList.add('hidden');
            document.body.classList.remove('modal-active');
        }

        encryptDecryptOption.addEventListener('click', (e) => {
            e.preventDefault();
            const link = e.target.closest('a');
            if (!link) return;
            const mode = link.textContent.toLowerCase().includes('cifrar') ? 'encrypt' : 'decrypt';
            showEncryptModal(mode);
            var instance = M.Dropdown.getInstance(document.getElementById('more-options-dropdown'));
            if (instance) instance.close();
        });

        editEncryptedOption.addEventListener('click', (e) => {
            e.preventDefault();
            const noteData = findNoteDataByDecodedName(currentEditingNoteName);
            if (noteData && noteData.content.startsWith(ENCRYPTION_PREFIX)) {
                showEncryptModal('edit-decrypt');
            }
            var instance = M.Dropdown.getInstance(document.getElementById('more-options-dropdown'));
            if (instance) instance.close();
        });

        cancelEncryptBtn.addEventListener('click', hideEncryptModal);
        encryptModalOverlay.addEventListener('click', hideEncryptModal);
        
        confirmEncryptBtn.addEventListener('click', () => {
            const password = encryptPasswordInput.value;
            if (!password) {
                M.toast({html: 'Por favor, introduce una contraseña.', classes: 'orange'});
                return;
            }

            const mode = encryptModal.dataset.mode;
            let currentContentInEditor = noteEditorContentEditable.innerHTML;
            const currentNoteData = findNoteDataByDecodedName(currentEditingNoteName);

            if (mode === 'encrypt') {
                currentContentInEditor = unprocessWikilinks(currentContentInEditor);
                if (currentContentInEditor.startsWith(ENCRYPTION_PREFIX)) {
                    M.toast({html: 'La nota ya está cifrada.', classes: 'blue'});
                } else {
                    const encrypted = CryptoJS.AES.encrypt(currentContentInEditor, password).toString();
                    noteEditorContentEditable.innerHTML = ENCRYPTION_PREFIX + encrypted;
                    M.toast({html: 'Nota cifrada. Cierra para guardar.', classes: 'green'});
                }
            } else if (mode === 'decrypt') {
                if (!currentNoteData.content.startsWith(ENCRYPTION_PREFIX)) {
                    M.toast({html: 'La nota no está cifrada.', classes: 'blue'});
                } else {
                    const contentToDecrypt = currentNoteData.content.substring(ENCRYPTION_PREFIX.length);
                    try {
                        const decryptedBytes = CryptoJS.AES.decrypt(contentToDecrypt, password);
                        const decryptedContent = decryptedBytes.toString(CryptoJS.enc.Utf8);
                        if (!decryptedContent) throw new Error("Contraseña incorrecta.");
                        noteEditorContentEditable.innerHTML = processWikilinks(decryptedContent);
                        noteEditorContentEditable.contentEditable = "true";
                        M.toast({html: 'Nota descifrada. Cierra para guardar.', classes: 'green'});
                    } catch (error) {
                        M.toast({html: 'Contraseña incorrecta.', classes: 'red'});
                    }
                }
            } else if (mode === 'edit-decrypt') {
                const originalEncryptedContent = currentNoteData ? currentNoteData.content : '';
                if (!originalEncryptedContent.startsWith(ENCRYPTION_PREFIX)) {
                     M.toast({html: 'La nota no está cifrada.', classes: 'blue'});
                } else {
                    const contentToDecrypt = originalEncryptedContent.substring(ENCRYPTION_PREFIX.length);
                    try {
                        const decryptedBytes = CryptoJS.AES.decrypt(contentToDecrypt, password);
                        const decryptedContent = decryptedBytes.toString(CryptoJS.enc.Utf8);
                        if (!decryptedContent) throw new Error("Contraseña incorrecta.");
                        
                        currentDecryptionKey = password;
                        isEditingEncryptedNote = true;
                        noteEditorContentEditable.innerHTML = processWikilinks(decryptedContent);
                        noteEditorContentEditable.contentEditable = "true";
                        noteEditorContentEditable.focus();
                        
                        initialEditorState.content = originalEncryptedContent;
                        
                        document.querySelectorAll('#more-options-dropdown li').forEach(li => li.style.display = 'block');
                        editEncryptedOption.parentElement.style.display = 'none';
                        
                    } catch (error) {
                         M.toast({html: 'Contraseña incorrecta.', classes: 'red'});
                    }
                }
            }
            hideEncryptModal();
        });

        document.getElementById('jump-to-note-btn').addEventListener('click', () => {
            const allVisibleNotes = Array.from(notesGridContainer.querySelectorAll('.note-card:not([style*="display: none"])'));
            if (allVisibleNotes.length === 0) return;

            let targetNotes = allVisibleNotes.filter(note => !note.classList.contains('pinned-note'));
            if (targetNotes.length === 0) {
                targetNotes = allVisibleNotes;
            }

            if (lastJumpedNoteIndex >= targetNotes.length - 1) {
                lastJumpedNoteIndex = -1;
            }

            lastJumpedNoteIndex++;
            const noteToJumpTo = targetNotes[lastJumpedNoteIndex];
            
            if (noteToJumpTo) {
                noteToJumpTo.scrollIntoView({ behavior: 'smooth', block: 'start' });
                
                document.querySelectorAll('.note-card.keyboard-focused').forEach(n => n.classList.remove('keyboard-focused'));
                noteToJumpTo.classList.add('keyboard-focused');
            }
        });

        // --- Global History Modal ---
          function hideGlobalHistoryModal() {
              globalHistoryModal.classList.add('hidden');
              globalHistoryModalOverlay.classList.add('hidden');
              document.body.classList.remove('modal-active');
              globalHistoryAllVersions = [];
              globalHistoryCurrentPage = 1;
          }

          globalHistoryBtn.addEventListener('click', (e) => {
              e.preventDefault();
              openGlobalHistoryModal();
          });
          closeGlobalHistoryModalBtn.addEventListener('click', hideGlobalHistoryModal);
          globalHistoryModalOverlay.addEventListener('click', hideGlobalHistoryModal);

          async function openGlobalHistoryModal() {
              globalHistoryModal.classList.remove('hidden');
              globalHistoryModalOverlay.classList.remove('hidden');
              document.body.classList.add('modal-active');
              globalHistoryContainer.innerHTML = "Cargando historial...";
              
              const dropdownElem = document.querySelector('#delete-older-dropdown');
              if (dropdownElem) {
                  M.Dropdown.init(document.querySelector('.dropdown-trigger[data-target="delete-older-dropdown"]'));
              }

              const versionsDir = webdavNotesUrl + ".versiones/";
              try {
                  const response = await fetch(versionsDir, { method: 'PROPFIND', headers: { 'Depth': '1' } });
                  if (response.status === 404) {
                      globalHistoryContainer.innerHTML = "No se encontraron versiones.";
                      return;
                  }
                  if (!response.ok) throw new Error(`Directorio de versiones no encontrado o inaccesible.`);
                  
                  const xmlText = await response.text();
                  const xml = new DOMParser().parseFromString(xmlText, "text/xml");
                  const responses = xml.getElementsByTagName("D:response");
                  let versions = [];
                  for(let r of responses) {
                      const href = r.getElementsByTagName("D:href")[0].textContent;
                      const fileName = decodeURIComponent(href.split('/').pop());
                      if (fileName.endsWith('.html')) {
                          versions.push(fileName);
                      }
                  }
                  
                  globalHistoryAllVersions = versions.sort().reverse();
                  globalHistoryCurrentPage = 1;
                  
                  if (globalHistoryAllVersions.length === 0) {
                      globalHistoryContainer.innerHTML = "No se encontraron versiones.";
                  } else {
                      renderGlobalHistoryPage();
                  }

              } catch(e) {
                  globalHistoryContainer.innerHTML = `Error: ${e.message}`;
              }
          }

          function renderGlobalHistoryPage() {
              const startIndex = (globalHistoryCurrentPage - 1) * globalHistoryVersionsPerPage;
              const endIndex = startIndex + globalHistoryVersionsPerPage;
              const versionsToShow = globalHistoryAllVersions.slice(startIndex, endIndex);

              if (versionsToShow.length === 0 && globalHistoryCurrentPage > 1) { // If on a page that is now empty
                  globalHistoryCurrentPage--;
                  renderGlobalHistoryPage();
                  return;
              } else if (versionsToShow.length === 0) {
                  globalHistoryContainer.innerHTML = "No hay más versiones.";
                  renderGlobalHistoryPagination();
                  return;
              }

              const ul = document.createElement('ul');
              versionsToShow.forEach(fileName => {
                  const li = document.createElement('li');
                  
                  const dateSpan = document.createElement('span');
                  dateSpan.className = 'version-date';
                  dateSpan.textContent = fileName;
                  
                  const viewBtn = document.createElement('a');
                  viewBtn.href = '#!';
                  viewBtn.className = 'btn-flat waves-effect';
                  viewBtn.innerHTML = 'Ver';
                  viewBtn.dataset.backupFile = fileName;
                  viewBtn.dataset.action = 'view-version';
                  
                  const restoreBtn = document.createElement('a');
                  restoreBtn.href = '#!';
                  restoreBtn.className = 'btn-flat waves-effect';
                  restoreBtn.innerHTML = 'Restaurar';
                  restoreBtn.dataset.backupFile = fileName;
                  restoreBtn.dataset.action = 'restore-version';

                  const deleteBtn = document.createElement('a');
                  deleteBtn.href = '#!';
                  deleteBtn.className = 'btn-flat waves-effect';
                  deleteBtn.innerHTML = '<i class="material-icons red-text">delete</i>';
                  deleteBtn.dataset.backupFile = fileName;
                  deleteBtn.dataset.action = 'delete-version';
                  
                  li.appendChild(dateSpan);
                  li.appendChild(viewBtn);
                  li.appendChild(restoreBtn);
                  li.appendChild(deleteBtn);
                  ul.appendChild(li);
              });
              globalHistoryContainer.innerHTML = '';
              globalHistoryContainer.appendChild(ul);
              
              renderGlobalHistoryPagination();
          }

          function renderGlobalHistoryPagination() {
              const totalPages = Math.ceil(globalHistoryAllVersions.length / globalHistoryVersionsPerPage);
              const paginationContainer = document.getElementById('global-history-pagination');
              paginationContainer.innerHTML = '';

              if (totalPages <= 1) return;

              const prevButton = document.createElement('a');
              prevButton.href = '#!';
              prevButton.className = 'btn-flat waves-effect';
              prevButton.innerHTML = '<i class="material-icons">chevron_left</i>';
              if (globalHistoryCurrentPage === 1) prevButton.classList.add('disabled');
              prevButton.addEventListener('click', () => {
                  if (globalHistoryCurrentPage > 1) {
                      globalHistoryCurrentPage--;
                      renderGlobalHistoryPage();
                  }
              });

              const nextButton = document.createElement('a');
              nextButton.href = '#!';
              nextButton.className = 'btn-flat waves-effect';
              nextButton.innerHTML = '<i class="material-icons">chevron_right</i>';
              if (globalHistoryCurrentPage === totalPages) nextButton.classList.add('disabled');
              nextButton.addEventListener('click', () => {
                  if (globalHistoryCurrentPage < totalPages) {
                      globalHistoryCurrentPage++;
                      renderGlobalHistoryPage();
                  }
              });
              
              const pageInfo = document.createElement('span');
              pageInfo.textContent = `Página ${globalHistoryCurrentPage} de ${totalPages}`;
              pageInfo.style.color = 'var(--text-muted)';
              
              paginationContainer.appendChild(prevButton);
              paginationContainer.appendChild(pageInfo);
              paginationContainer.appendChild(nextButton);
          }


          globalHistoryContainer.addEventListener('click', (e) => {
              const target = e.target.closest('a');
              if (!target) return;

              const action = target.dataset.action;
              const backupFile = target.dataset.backupFile;

              if (action === 'restore-version') {
                  if (confirm(`¿Restaurar la versión "${backupFile}" como una nueva nota?`)) {
                      restoreVersionAsNewNote(backupFile);
                  }
              } else if (action === 'view-version') {
                  showVersionPreview(backupFile);
              } else if (action === 'delete-version') {
                  if(confirm(`¿Borrar permanentemente la versión "${backupFile}"?`)) {
                      deleteBackupVersion(backupFile).then(() => {
                          globalHistoryAllVersions = globalHistoryAllVersions.filter(v => v !== backupFile);
                          renderGlobalHistoryPage();
                      });
                  }
              }
          });

          async function deleteBackupVersion(backupFileName) {
              const backupUrl = webdavNotesUrl + ".versiones/" + encodeURIComponent(backupFileName);
              try {
                  const response = await fetch(backupUrl, { method: 'DELETE' });
                  if (!response.ok && response.status !== 204) throw new Error(`Error: ${response.status}`);
                  M.toast({html: 'Versión eliminada.', classes: 'green'});
              } catch (error) {
                  M.toast({html: `Error al eliminar: ${error.message}`, classes: 'red'});
              }
          }

          async function restoreVersionAsNewNote(backupFileName) {
              M.toast({html: 'Restaurando como nota nueva...'});
              showProgress();
              const backupUrl = webdavNotesUrl + ".versiones/" + encodeURIComponent(backupFileName);
              const newNoteName = backupFileName.replace('.html', ''); // Use backup filename as new note name
              const newNotePath = webdavNotesUrl + encodeURIComponent(newNoteName) + ".html";

              try {
                  const backupResponse = await fetch(backupUrl);
                  if (!backupResponse.ok) throw new Error('No se pudo leer el archivo de respaldo.');
                  const backupContent = await backupResponse.text();

                  const restoreResponse = await fetch(newNotePath, {
                      method: 'PUT',
                      headers: { 'Content-Type': 'text/html; charset=UTF-8' },
                      body: backupContent
                  });
                  if (!restoreResponse.ok && !/20[0-9]/.test(restoreResponse.status)) throw new Error('Error al crear la nota nueva.');

                  M.toast({html: 'Nota restaurada con éxito.', classes: 'green'});
                  hideGlobalHistoryModal();
                  fetchNotesAndDisplayCards();
              } catch (error) {
                  M.toast({html: `Error: ${error.message}`, classes: 'red'});
              } finally {
                  hideProgress();
              }
          }
          
          document.getElementById('delete-older-dropdown').addEventListener('click', async (e) => {
              e.preventDefault();
              const days = e.target.dataset.days;
              if (days && confirm(`¿Borrar todas las versiones de más de ${days} días? Esta acción no se puede deshacer.`)) {
                  await bulkDeleteOldVersions(parseInt(days, 10));
              }
          });
          
          async function bulkDeleteOldVersions(days) {
              M.toast({html: `Eliminando versiones antiguas...`});
              showProgress();
              const versionsDir = webdavNotesUrl + ".versiones/";
              const cutoffDate = new Date();
              cutoffDate.setDate(cutoffDate.getDate() - days);

              try {
                  const response = await fetch(versionsDir, { method: 'PROPFIND', headers: { 'Depth': '1' } });
                  if (!response.ok) throw new Error(`No se pudo acceder al historial.`);

                  const xmlText = await response.text();
                  const xml = new DOMParser().parseFromString(xmlText, "text/xml");
                  const responses = xml.getElementsByTagName("D:response");
                  let filesToDelete = [];

                  for (let r of responses) {
                      const href = r.getElementsByTagName("D:href")[0].textContent;
                      const fileName = decodeURIComponent(href.split('/').pop());
                      if (!fileName.endsWith('.html')) continue;
                      
                      const timestamp = fileName.split('-')[0];
                      if(timestamp.length < 15) continue;
                      const fileDate = new Date(`${timestamp.substring(0,4)}-${timestamp.substring(4,6)}-${timestamp.substring(6,8)}T${timestamp.substring(9,11)}:${timestamp.substring(11,13)}:${timestamp.substring(13,15)}`);
                      
                      if (fileDate < cutoffDate) {
                          filesToDelete.push(fileName);
                      }
                  }

                  if (filesToDelete.length === 0) {
                      M.toast({html: 'No hay versiones antiguas que borrar.'});
                      return;
                  }
                  const deletePromises = filesToDelete.map(fileName => deleteBackupVersion(fileName));
                  await Promise.all(deletePromises);

                  M.toast({html: `${filesToDelete.length} versiones antiguas eliminadas.`, classes: 'green'});
                  await openGlobalHistoryModal(); // Refresh the list

              } catch (e) {
                  M.toast({html: `Error en borrado masivo: ${e.message}`, classes:'red'});
              } finally {
                  hideProgress();
              }
          }

          async function reorderPinnedNote(noteName, direction) {
              const index = currentPinnedNotesList.indexOf(noteName);
              if (index === -1) return;

              let newIndex;
              if (direction === 'up') {
                  if (index === 0) return; // Already at the top
                  newIndex = index - 1;
              } else { // 'down'
                  if (index === currentPinnedNotesList.length - 1) return; // Already at the bottom
                  newIndex = index + 1;
              }

              // Swap elements
              const temp = currentPinnedNotesList[newIndex];
              currentPinnedNotesList[newIndex] = currentPinnedNotesList[index];
              currentPinnedNotesList[index] = temp;

              // Save the new order and redraw the notes
              try {
                  await savePinnedNotesToServer(currentPinnedNotesList);
                  displaySortedNotes(Array.from(allNotesDataMap.values()));
                  M.toast({html: 'Orden de notas fijadas actualizado.', classes: 'blue'});
              } catch (error) {
                  M.toast({html: `Error al reordenar: ${error.message}`, classes: 'red'});
                  // Revert on error if needed, though a full refresh would also fix it
              }
          }

          async function moveNote(noteFullName, destinationPath) {
              const noteData = allNotesDataMap.get(noteFullName);
              if (!noteData) {
                  M.toast({html: 'No se encontró la nota para mover.', classes: 'red'});
                  return;
              }

              const destinationUrl = new URL(destinationPath + noteData.fullName, window.location.origin).href;
              const originalUrl = noteData.path;
              
              showProgress();
              try {
                  const moveResponse = await fetch(originalUrl, {
                      method: 'MOVE',
                      headers: { 'Destination': destinationUrl, 'Overwrite': 'F' }
                  });

                  if (!moveResponse.ok || !/20[0-9]/.test(moveResponse.status)) {
                       throw new Error(`Error al mover: ${moveResponse.statusText}`);
                  }
                  
                  M.toast({html: `Nota movida a ${destinationPath.split('/').filter(Boolean).pop()}.`, classes: 'green'});
                  
                  // Remove note from current view
                  allNotesDataMap.delete(noteFullName);
                  const cardElement = document.querySelector(`.note-card[data-full-name="${noteFullName}"]`);
                  if(cardElement) cardElement.remove();

                  if (isNotePinned(noteData.name)) {
                      const newPinnedList = currentPinnedNotesList.filter(name => name !== noteData.name);
                      await savePinnedNotesToServer(newPinnedList);
                  }

                  updateSidebarCounts();

              } catch (err) {
                  M.toast({html: `Error al mover la nota: ${err.message}`, classes: 'red'});
              } finally {
                  hideProgress();
              }
          }

          document.body.addEventListener('click', e => {
              const target = e.target.closest('a[data-action="move-to"]');
              if (target) {
                  e.preventDefault();
                  const noteFullName = target.dataset.noteFullName || findNoteDataByDecodedName(currentEditingNoteName)?.fullName;
                  const destinationPath = target.dataset.path;
                  
                  if (noteFullName && destinationPath) {
                      moveNote(noteFullName, destinationPath);
                      if(!modalEditorContainer.classList.contains('hidden')) {
                          hideEditorView();
                      }
                  }
              }
          });
      })(); // End of async wrapper for config loading
    });
  </script>
</body>
</html>
